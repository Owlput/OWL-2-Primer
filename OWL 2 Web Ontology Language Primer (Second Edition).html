<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head>
  <title>OWL 2 网络本体描述语言 引入 （第二版）</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <style type="text/css">
   .editsection { display: none; }
</style>
<link href="OWL%202%20Web%20Ontology%20Language%20Primer%20(Second%20Edition)_files/owl.css" rel="stylesheet" type="text/css">
<link href="OWL%202%20Web%20Ontology%20Language%20Primer%20(Second%20Edition)_files/Primer.css" rel="stylesheet" type="text/css">
<link href="http://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css">

  
</head>
<body>

<div class="head">
<a href="http://www.w3.org/"><img alt="W3C" src="OWL%202%20Web%20Ontology%20Language%20Primer%20(Second%20Edition)_files/w3c_home.svg" width="72" height="48"></a>
<h1 id="title" style="clear:both">
  OWL 2 本体描述语言 <br><span id="short-title">引入 (第二版)</span>
</h1>

<h2 id="W3C-doctype">W3C推荐 2012年12月11日</h2>

<!-- no inplace warning -->
<dl>
<dt>当前版本：</dt>
<dd><a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/" id="this-version-url">http://www.w3.org/TR/2012/REC-owl2-primer-20121211/</a></dd>

<dt>最新版本 （系列二）：</dt>
<dd><a href="http://www.w3.org/TR/owl2-primer/">http://www.w3.org/TR/owl2-primer/</a></dd>

<dt>最新推荐：</dt>
<dd><a href="http://www.w3.org/TR/owl-primer">http://www.w3.org/TR/owl-primer</a></dd>

<dt>旧版：</dt>
<dd><a href="http://www.w3.org/TR/2012/PER-owl2-primer-20121018/">http://www.w3.org/TR/2012/PER-owl2-primer-20121018/</a></dd>
</dl>

<dl><dt>编辑：</dt><dd><a href="http://www.pascal-hitzler.de/">Pascal Hitzler</a>, 莱特州立大学</dd>
<dd><a href="http://korrekt.org/">Markus Krötzsch</a>, 牛津大学</dd>
<dd><a href="http://www.cs.man.ac.uk/~bparsia/">Bijan Parsia</a>, 曼彻斯特大学</dd>
<dd>Peter F. Patel-Schneider, Nuance Communications</dd>
<dd><a href="http://www.sebastian-rudolph.de/">Sebastian Rudolph</a>, FZI Research Center for Information Technology</dd>
</dl>

<p>请参照本文档相关的 <a href="http://www.w3.org/2007/OWL/errata"><strong>勘误表</strong></a> 获取可能的规范修正。</p>

<p>在此处可以获得<a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/diff-from-20121018">以颜色标注出在旧版之上经改动部分的本文档</a>。</p><p>本文档也有非规范格式的版本: <a href="http://www.w3.org/2012/pdf/REC-owl2-primer-20121211.pdf">PDF版</a>.</p>

<p>在 <a href="http://www.w3.org/2007/OWL/translation/owl2-syntax">此处</a>查阅翻译。</p>

<p class="copyright">
  <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">版权所有</a> © 2012 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> 
  (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), 
  保留所有权利. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">免责声明</a>, 
  <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">商标</a> 和 <a href="http://www.w3.org/Consortium/Legal/copyright-documents">文档使用事项</a> 适用于本文档。</p>

</div>
<hr>
<h2><a id="abstract" name="abstract">概要</a></h2>

<div>
<div><p>
  OWL 2 网络本体描述语言， 非正式称为 OWL 2，是一个为语义Web所开发的，有严格定义的本体描述语言。
OWL 2 定义的本体提供类、属性、个体和数据值，并能被存储为语义Web文档。
OWL 2 定义的本体可以与在RDF内存储的信息一同使用，其本身也主要以RDF文档的形式传输。
OWL 2 <a href="http://www.w3.org/TR/2012/REC-owl2-overview-20121211/" title="Document Overview">文档概览</a>描述了OWL 2的概况，并也应该作为阅读其他 OWL 2 文档的前置准备。</p><p>
<p>
  本引入提供易于理解的OWL 2介绍，包括适用于不了解 OWL 的人的参考大纲、使用
  OWL 2来表达简单到丰富信息的示例、OWL 2 如何管理本体，和OWL 2不同子语言之间的区别。</p></div>
</div>

<h2 class="no-toc no-num">
<a id="w3c_status" name="w3c_status">文档状态</a>
</h2>
    
<h4 class="no-toc no-num" id="may-be">可能被取代</h4>
    
<p><em>
  本页面描述的是本文档公布时的状态。其他文档可能取代本文档。
  在<a href="http://www.w3.org/TR/">W3C技术报告目录</a>可以找到当前的W3C发布内容
  和本文档的最新修订版。
</em></p>

    

<!-- no eventStatusExtra -->

<!-- no statusExtra -->

<div></div>
 <h4 class="no-toc no-num" id="status-changes">更改概览</h4>
<div>
  自<a href="http://www.w3.org/TR/2012/PER-owl2-primer-20121018/">前一版本</a>发布后，尚无<a href="http://www.w3.org/2005/10/Process-20051014/tr#substantive-change">实质性</a>更改。
  如需获取小改动的详细信息请参阅<a href="#changelog">更改记录</a>和<a href="http://www.w3.org/TR/2012/REC-owl2-primer-20121211/diff-from-20121018">更改高亮</a>。
</div>

<h4 class="no-toc no-num" id="please">请求评论</h4>
  <p>
    请将评论发送至 <a class="mailto" href="mailto:public-owl-comments@w3.org">public-owl-comments@w3.org</a>
    (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-comments/">公开存档</a>)。
    尽管<a href="http://www.w3.org/2007/OWL/">OWL Working Group</a>已经完成本文档， 评论仍可以在<a href="http://www.w3.org/2007/OWL/errata">勘误表</a>或未来修订中被提及或解决。
    欢迎开发者们在<a class="mailto" href="mailto:public-owl-dev@w3.org">public-owl-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-owl-dev/">公开存档</a>)中自由讨论。
  </p>
    
<h4 class="no-toc no-num" id="endorsement">已获得W3C认可</h4>
<p><em>
  本文档已通过W3C成员、软件开发者、其他W3C工作组和相关人士审核，并作为W3C推荐获得W3C理事认可。
  本文档已成为稳定文档，可以作为参考资料使用或被其他文档引用。
  W3C 做出推荐的目的是为标准吸引注意并推进其应用。
  本文档所涉技术能够增强万维网的功能和互操作性。
</em></p>


<h4 class="no-toc no-num" id="patents">专利相关</h4>
    
<p><em>本文档由在<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>下运作的团体创作。
  本文档仅供参考。W3C维护着一份与OWL Working Group相关的<a href="http://www.w3.org/2004/01/pp-impl/41712/status" rel="disclosure">已披露的专利的公开列表</a>。此页面也包括公开专利方面的指导。
</em></p>

<hr title="Separator After Status Section">

<script type="text/javascript" async="" src="OWL%202%20Web%20Ontology%20Language%20Primer%20(Second%20Edition)_files/matomo.js"></script><script type="text/javascript">/*<![CDATA[*/
/*
	Written by Jonathan Snook, http://www.snook.ca/jonathan
	Add-ons by Robert Nyman, http://www.robertnyman.com
	Author says "The credit comment is all it takes, no license. Go crazy with it!:-)"
	From http://www.robertnyman.com/2005/11/07/the-ultimate-getelementsbyclassname/
*/

var displayed = [];
displayed["fssyntax"] = 0;
displayed["rdfxml"] = 0;
displayed["turtle"] = 0;
displayed["manchester"] = 0;
displayed["owlxml"] = 0;

function primerOnLoad() {
  display('rdfxml', 'none');      set_display_by_id('hide-rs', 'none');       set_display_by_id('show-rs', '');
  display('turtle', 'none');      set_display_by_id('hide-ts', 'none');       set_display_by_id('show-ts', '');
  display('manchester', 'none');  set_display_by_id('hide-ms', 'none');       set_display_by_id('show-ms', '');
  display('owlxml', 'none');      set_display_by_id('hide-xs', 'none');       set_display_by_id('show-xs', '');
}

function display(syntax,status) {
  var howmany = 0;
  if (status=='none') {
    displayed[syntax] = 0; 
  } else { 
    displayed[syntax] = 1;
  }
  for ( i in displayed ) {
       howmany = howmany + displayed[i];
  }
  set_display_by_class('div',syntax,status);
  if ( howmany == 1 ) {
      set_display_by_class('b','syntax-head','none');
  } else {
      set_display_by_class('b','syntax-head','');
  }
}

function getElementsByClassName(oElm, strTagName, oClassNames){
	var arrElements = (! (! (strTagName == "*") || ! (oElm.all)))? oElm.all : oElm.getElementsByTagName(strTagName);
	var arrReturnElements = new Array();
	var arrRegExpClassNames = new Array();
	if(typeof oClassNames == "object"){
		for(var i=0; !(i>=oClassNames.length); i++){ /*>*/
			arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames[i].replace(/\-/g, "\\-") + "(\\s|$)"));
		}
	}
	else{
		arrRegExpClassNames.push(new RegExp("(^|\\s)" + oClassNames.replace(/\-/g, "\\-") + "(\\s|$)"));
	}
	var oElement;
	var bMatchesAll;
	for(var j=0; !(j>=arrElements.length); j++){ /*>*/
		oElement = arrElements[j];
		bMatchesAll = true;
		for(var k=0; !(k>=arrRegExpClassNames.length); k++){ /*>*/
			if(!arrRegExpClassNames[k].test(oElement.className)){
				bMatchesAll = false;
				break;
			}
		}
		if(bMatchesAll){
			arrReturnElements.push(oElement);
		}
	}
	return (arrReturnElements)
}

function set_display_by_class(el, cls, newValue) {
   var e = getElementsByClassName(document, el, cls);
   if (e != null) {
      for (var i=0; !(i>=e.length); i++) {
        e[i].style.display = newValue;
      }
   }
}

function set_display_by_id(id, newValue) {
   var e = document.getElementById(id);
   if (e != null) {
     e.style.display = newValue;
   }
}
/*]]>*/
</script>


<table class="toc" id="toc" summary="Contents"><tbody><tr><td><div id="toctitle"><h2>目录</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">介绍</span></a>
<ul>
<li class="toclevel-2"><a href="#Guide_to_this_Document"><span class="tocnumber">1.1</span> <span class="toctext">如何阅读本文档</span></a></li>
<li class="toclevel-2"><a href="#OWL_Syntaxes"><span class="tocnumber">1.2</span> <span class="toctext">OWL 语法</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#What_is_OWL_2.3F"><span class="tocnumber">2</span> <span class="toctext">什么是 OWL 2?</span></a></li>
<li class="toclevel-1"><a href="#Modeling_Knowledge:_Basic_Notions"><span class="tocnumber">3</span> <span class="toctext">建模知识：基本概念</span></a></li>
<li class="toclevel-1"><a href="#Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them"><span class="tocnumber">4</span> <span class="toctext">类, 属性, 和个体 – 还有使用他们的基础建模</span></a>
<ul>
<li class="toclevel-2"><a href="#Classes_and_Instances"><span class="tocnumber">4.1</span> <span class="toctext">类及其实例</span></a></li>
<li class="toclevel-2"><a href="#Class_Hierarchies"><span class="tocnumber">4.2</span> <span class="toctext">类的层次结构</span></a></li>
<li class="toclevel-2"><a href="#Class_Disjointness"><span class="tocnumber">4.3</span> <span class="toctext">类的不交性</span></a></li>
<li class="toclevel-2"><a href="#Object_Properties"><span class="tocnumber">4.4</span> <span class="toctext">对象的属性</span></a></li>
<li class="toclevel-2"><a href="#Property_Hierarchies"><span class="tocnumber">4.5</span> <span class="toctext">属性的层次结构</span></a></li>
<li class="toclevel-2"><a href="#Domain_and_Range_Restrictions"><span class="tocnumber">4.6</span> <span class="toctext">作用域和作用范围限制</span></a></li>
<li class="toclevel-2"><a href="#Equality_and_Inequality_of_Individuals"><span class="tocnumber">4.7</span> <span class="toctext">实例间的相等性和不等性</span></a></li>
<li class="toclevel-2"><a href="#Datatypes"><span class="tocnumber">4.8</span> <span class="toctext">数据类型</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Class_Relationships"><span class="tocnumber">5</span> <span class="toctext">类关系进阶</span></a>
<ul>
<li class="toclevel-2"><a href="#Complex_Classes"><span class="tocnumber">5.1</span> <span class="toctext">复合类</span></a></li>
<li class="toclevel-2"><a href="#Property_Restrictions"><span class="tocnumber">5.2</span> <span class="toctext">使用属性限制定义类</span></a></li>
<li class="toclevel-2"><a href="#Property_Cardinality_Restrictions"><span class="tocnumber">5.3</span> <span class="toctext">对属性持有的值做出限制</span></a></li>
<li class="toclevel-2"><a href="#Enumeration_of_Individuals"><span class="tocnumber">5.4</span> <span class="toctext">通过列举实例定义类</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Use_of_Properties"><span class="tocnumber">6</span> <span class="toctext">属性的进阶用法</span></a>
<ul>
<li class="toclevel-2"><a href="#Property_Characteristics"><span class="tocnumber">6.1</span> <span class="toctext">属性性质</span></a></li>
<li class="toclevel-2"><a href="#Property_Chains"><span class="tocnumber">6.2</span> <span class="toctext">属性链</span></a></li>
<li class="toclevel-2"><a href="#Keys"><span class="tocnumber">6.3</span> <span class="toctext">关键字</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Advanced_Use_of_Datatypes"><span class="tocnumber">7</span> <span class="toctext">数据类型的进阶用法</span></a></li>
<li class="toclevel-1"><a href="#Document_Information_and_Annotations"><span class="tocnumber">8</span> <span class="toctext">文档信息和注解</span></a>
<ul>
<li class="toclevel-2"><a href="#Annotating_Axioms_and_Entities"><span class="tocnumber">8.1</span> <span class="toctext">为实体和共识添加注解</span></a></li>
<li class="toclevel-2"><a href="#Ontology_Management"><span class="tocnumber">8.2</span> <span class="toctext">本体管理</span></a></li>
<li class="toclevel-2"><a href="#Entity_Declarations"><span class="tocnumber">8.3</span> <span class="toctext">实体声明</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#OWL_2_DL_and_OWL_2_Full"><span class="tocnumber">9</span> <span class="toctext">OWL 2 DL 和 OWL 2 Full</span></a></li>
<li class="toclevel-1"><a href="#OWL_2_Profiles"><span class="tocnumber">10</span> <span class="toctext">OWL 2 预设</span></a>
<ul>
<li class="toclevel-2"><a href="#OWL_2_EL"><span class="tocnumber">10.1</span> <span class="toctext">OWL 2 EL</span></a></li>
<li class="toclevel-2"><a href="#OWL_2_QL"><span class="tocnumber">10.2</span> <span class="toctext">OWL 2 QL</span></a></li>
<li class="toclevel-2"><a href="#OWL_2_RL"><span class="tocnumber">10.3</span> <span class="toctext">OWL 2 RL</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#OWL_Tools"><span class="tocnumber">11</span> <span class="toctext">OWL 工具</span></a></li>
<li class="toclevel-1"><a href="#What_To_Read_Next"><span class="tocnumber">12</span> <span class="toctext">接下来该读什么</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_The_Complete_Sample_Ontology"><span class="tocnumber">13</span> <span class="toctext">附录：完整示例本体</span></a></li>
<li class="toclevel-1"><a href="#Appendix:_Change_Log_.28Informative.29"><span class="tocnumber">14</span> <span class="toctext">附录：更改记录 (仅供参考)</span></a>
<ul>
<li class="toclevel-2"><a href="#Changes_Since_Recommendation"><span class="tocnumber">14.1</span> <span class="toctext">成为推荐后做出的更改</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Proposed_Recommendation"><span class="tocnumber">14.2</span> <span class="toctext">提议为推荐之前做出的更改</span></a></li>
<li class="toclevel-2"><a href="#Changes_Since_Last_Call"><span class="tocnumber">14.3</span> <span class="toctext">最后一次通讯后做出的更改</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Acknowledgments"><span class="tocnumber">15</span> <span class="toctext">鸣谢</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">16</span> <span class="toctext">参考资料</span></a></li>
</ul>
</td></tr></tbody></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<p><br>
</p><p><br>
</p>
<a id="Introduction" name="Introduction"></a><h2> <span class="mw-headline">1  介绍 </span></h2>
<p>
  W3C OWL 2 网络本体描述语言（简称 OWL）是一门为语义Web开发的语言，旨在描述丰富且复杂的信息、事物集合和事物之间的关系。
  OWL 是一门基于逻辑的，可用计算机处理的语言，以便计算机理解使用 OWL 描述的信息，并验证其一致性或推断其隐含的信息。
  OWL 文档，称为<span class="first term">本体</span>，可以被发布到万维网上，并可引用其他本体或被其他本体引用。
  OWL 是 W3C <a class="external text" href="http://www.w3.org/2001/sw/" rel="nofollow" title="http://www.w3.org/2001/sw/">语义Web</a>
  技术栈的一部分。该技术栈包括 RDF [<cite><a href="#ref-rdf-concepts" title="">RDF 概念</a></cite>] 和 SPARQL [<cite><a href="#ref-sparql" title="">SPARQL</a></cite>]。
</p>
<p>
  本引入的主要目标在于帮助人们深入了解 OWL，以及它的强项和缺点。
  本引入的核心内容为使用一个符合规范的示例来介绍 OWL 的主要特性。
  本引入中的大部分示例均来自该示例本体（详见<a href="#Appendix:_The_Complete_Sample_Ontology" title="">附录：完整示例本体</a>）。
  此示例本体旨在以容易理解的方式介绍 OWL 的语言特性，而非作为一个好的示例。
</p>
<a id="Guide_to_this_Document" name="Guide_to_this_Document"></a><h3> <span class="mw-headline">1.1 关于本文档</span></h3>
<p>
  本文档旨在提供对 OWL 2 的初级理解，特别针对尚不熟悉本话题的人。
  因此，我们将在第二节以给出一些 OWL 2 性质的简要介绍。
  第三节将给出在信息呈现方面的一些非常基础的注解，并解释它们与 OWL 2 中的术语的联系。
  熟悉信息呈现和理解的读者可能仅需略读本节即可熟悉 OWL 2 中的术语。
</p>
<p>
  第四到八节将描述 OWL 的大部分特性，并以由浅入深的方式介绍它们。
  <a href="#Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them" title="">第四节</a>将介绍并讨论
  OWL 在建模方面的基本特性。
  <a href="#Advanced_Class_Relationships" title="">第五节</a>将介绍复合类。
  <a href="#Advanced_Use_of_Properties" title="">第六节</a>将介绍使用属性建模的高级特性。
  <a href="#Advanced_Use_of_Datatypes" title="">第七节</a>将着重介绍与数据类型相关联的更高级建模方法。
  <a href="#Document_Information_and_Annotations" title="">第八节</a>将总结主要用于管理本体的非逻辑特性。
</p>
<p>
  在<a href="#OWL_2_DL_and_OWL_2_Full" title="">第九节</a>中我们将介绍 OWL 2 DL 和 OWL 2 Full ，两个不同语义角度之间的区别，
  而在<a href="#OWL_2_Profiles" title="">第十节</a>我们将介绍 OWL 2 中三种比较容易处理的子语言，称为语言预设。
  在<a href="#OWL_Tools" title="">第十一节</a>中我们将介绍 OWL 2 可用的工具。
  在<a href="#What_To_Read_Next" title="">第十二节</a>中我们将给出在阅读完本文档之后推荐继续阅读的材料。
</p>
<p>
  最后，<a href="#Appendix:_The_Complete_Sample_Ontology" title="">第十三节</a>中将给出本文档中使用的示例本体的完整版。
</p>
<p>
  如需获得一份完整的 OWL 2 特性列表，请阅读 OWL 2 速查表[<cite><a href="#ref-owl-2-quick-reference" title="">OWL 2 速查表</a></cite>]。
  该速查表提供格式和示例对应的文档部分的链接。
</p>
<p>
  对于熟悉 OWL 1 的读者，<cite><a href="#ref-owl-2-new-features" title="">OWL 2 新特性和目标</a></cite>提供了易于理解的更改概览。
</p>
<a id="OWL_Syntaxes" name="OWL_Syntaxes"></a><h3> <span class="mw-headline">1.2 OWL 格式</span></h3>
<p>
  OWL 是一门用于语义 Web 的语言，所以 OWL 中的名称均为国际化资源标识符（IRI）[<cite><a href="#ref-rfc-3987" title="">RFC 3987</a></cite>]。
  鉴于 IRI 很长，我们将会经常使用缩写来在 OWL 中记录它们。
  如何理解这些缩写与语法格式紧密相关，但在不知晓其细节的情况下本文档中使用的示例也能被理解。
  在 <a href="#Ontology_Management" title="">8.2节</a>中将给出命名空间注释及其机制。
</p>
<p>
  OWL 可以使用许多不同的语法以满足不同需求。函数式语法[<cite><a href="#ref-owl-2-specification" title="">OWL 2 标准规范</a></cite>]
  意在使建立标准更为便捷，并为API和推理器等 OWL 2 工具的实现提供基础。
  OWL 的 RDF/XML 语法本质上仍是 RDF/XML，但带有 OWL 结构转译：[<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF 映射</a></cite>]。
  这是唯一一个所有 OWL 2 工具都必须支持的语法。
  曼彻斯特语法[<cite><a href="#ref-owl-2-manchester-syntax" title="">OWL 2 曼彻斯特语法</a></cite>]是为方便非逻辑学者阅读而设计的语法。
  OWL XML 语法是由 XML 格式[<cite><a href="#ref-owl-2-xml-serialization" title="">OWL 2 XML</a></cite>]定义的 XML 语法。
  当前存在提供 OWL 语法转换的工具。在众多语法形式中，OWL 语言结构也能由 IRI 表示，同时可能需要适当注释来使用其缩写形式。
  同样，<a href="#Ontology_Management" title="">8.2节</a>将提供必要的细节。
</p>
<p>
  附录中的示例和示例本体均可以用四种不同的语法来表现，下面提供 RDF/XML [<cite><a href="#ref-rdf-syntax" title="">RDF 语法</a></cite>]
  和 Turtle [<cite><a href="#ref-turtle" title="">Turtle</a></cite>] 序列化 作为基于RDF语法的示例。
  下方的按钮可以用于控制这些语法示例在整个文档中的可见性。
</p>

<p></p>

<div class="syntaxmenu">
<p>下方的按钮可以用于设置不同语法的可见性。</p><form action=""><p>
<input id="hide-fs" onclick="display('fssyntax','none');    set_display_by_id('hide-fs', 'none'); set_display_by_id('show-fs', '');"     type="button" style="display: none;" value="隐藏函数式语法">
<input id="show-fs" onclick="display('fssyntax','');        set_display_by_id('hide-fs', '');     set_display_by_id('show-fs', 'none');" type="button" style=""               value="显示函数式语法">
<input id="hide-rs" onclick="display('rdfxml', 'none');     set_display_by_id('hide-rs', 'none'); set_display_by_id('show-rs', '');"     type="button" style="display: none;" value="隐藏 RDF/XML 语法" >
<input id="show-rs" onclick="display('rdfxml', '');         set_display_by_id('hide-rs', '');     set_display_by_id('show-rs', 'none');" type="button" style=""               value="显示 RDF/XML 语法">
<input id="hide-ts" onclick="display('turtle', 'none');     set_display_by_id('hide-ts', 'none'); set_display_by_id('show-ts', '');"     type="button" style="display: none;" value="隐藏 Turtle 语法" >
<input id="show-ts" onclick="display('turtle', '');         set_display_by_id('hide-ts', '');     set_display_by_id('show-ts', 'none');" type="button" style=""               value="显示 Turtle 语法">
<input id="hide-ms" onclick="display('manchester', 'none'); set_display_by_id('hide-ms', 'none'); set_display_by_id('show-ms', '');"     type="button" style="display: none;" value="隐藏曼彻斯特语法" >
<input id="show-ms" onclick="display('manchester','');      set_display_by_id('hide-ms', '');     set_display_by_id('show-ms', 'none');" type="button" style=""               value="显示曼彻斯特语法">
<input id="hide-xs" onclick="display('owlxml', 'none');     set_display_by_id('hide-xs', 'none'); set_display_by_id('show-xs', '');"     type="button" style="display: none;" value="隐藏 OWL/XML 语法">
<input id="show-xs" onclick="display('owlxml', '');         set_display_by_id('hide-xs', '');     set_display_by_id('show-xs', 'none');" type="button" style=""               value="显示 OWL/XML 语法">
</p></form>
</div>
<p>  

</p>
<a id="What_is_OWL_2.3F" name="What_is_OWL_2.3F"></a><h2> <span class="mw-headline">2 OWL 2 是什么?</span></h2>
<p>
  OWL 2 是一门用于描述<i>本体</i>的语言。
  <i>本体</i>这一词不论是在计算机领域还是其他领域都有着复杂的历史，但在这里我们
  认为它代表一种计算机可处理的对象，比如一个程序、一个 XML 文档，或者是一个网页。
  他们通常都以文档的形式展现。一个本体是一系列精确描述世界上某个事物的语句，
  这些语句通常被称为本体的<i>关联域（domain of interest）</i>或<i>主题（subject matter）</i>。
  这些准确的描述能满足许多需求，其中最重要的是它们能够尽量消除人与人交流中存在的偏差，
  并保证软件的行为是统一的、可预测的，也让它们能与其他软件兼容。
</p>
<p>
  为了能准确描述一个关联域，预先创造一系列关键术语 —— 通常被成为词汇表（Vocabulary）——
  并固定它们的意义将有极大帮助。
  在使用一些简洁的自然语言之外，也可以通过描述某一术语与其他术语之间的联系来描述其含义。
  由<i>术语（terminology）</i>组成的词汇表与其相关信息是一个典型 OWL 2 文档的重要组成部分。
  除了术语上的信息，一个本体也可能包含断言信息（assertional knowledge）。
  断言处理相关领域的具体信息而非一般概念。
</p>
<p>
  OWL 2 不是一门编程语言：OWL 2 是<i>声明性的</i>。
  也就是说，它被用于从逻辑的角度描述某个事物的状态。
  恰当的工具（通常被称为推理器）可以用于推断某一本体背后包含的更多信息。
  如何在算法上实现推断并不在 OWL 文档的讨论范围内，而取决于具体的实现。
  尽管如此，这些推断的正确结果仍由正式语义决定（有两种版本的语义：
  <i>Direct Semantics</i> [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>]
  和<i>RDF-Based Semantics</i> [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>]）。 
  只有遵循这些语义的实现才会被认为是“OWL 2 兼容”的（详见[<cite><a href="#ref-owl-2-conformance" title="">OWL 2 Conformance</a></cite>]）。
  由于其解释性的本质，构建一个 OWL 2 文档与编程存在根本上的不同。
  但是，由于二者都涉及构建标准化的复杂文档，软件工程方面的某些概念也可以应用于
  本体设计，如方法论、协作性、模块化、固定模式等。
</p>
<p>
  OWL 2 不对语法一致性做出要求。不像 XML ，OWL 2 没有提出与文档语法结构相关的具体要求。
  例如，无法使某些信息（如某人的社保号）成为格式的一部分，使其必须存在。
  应牢记这一点，因为 OWL 中的部分特性可能会因此被用户误解。
</p>
<p>
  OWL 2 不是一个数据库框架。尽管 OWL 2 文档与数据库一样能够存储信息， 
  断言信息和数据库信息之间、术语信息和数据库结构之间也存在相似性，
  但这样的类比常常忽略了这些概念的关键差异（技术上说：这些概念所使用的语义）。
  例如，如果某些事实不存在于数据库中，那它通常被认为是假的，遵从封闭世界假定(closed-world assumption)；
  而在 OWL 2 文档中，该事实可能仅仅是丢失了（而非是假的），遵从开放世界假定(open-world assumption)。
  此外，数据库结构中通常带有上述的限制性语义。
  尽管如此，技术上说，数据库仍在许多面向本体的系统中作为可靠的支柱。
</p>
<a id="Modeling_Knowledge:_Basic_Notions" name="Modeling_Knowledge:_Basic_Notions"></a><h2> <span class="mw-headline">3  建模知识：基本概念</span></h2>
<p>
  OWL 2 是一门用于表现知识的语言，用于生产、交换和推理某一兴趣域的知识。
  为了理解知识在 OWL 2 中的表现形式，有些基本概念必须被提前介绍。
  这些基本概念有：
</p>
<ul><li> <b>定理（Axioms）：</b> OWL 本体所表达的基本陈述内容
</li><li> <b>实体（Entities）：</b> 用于指代现实世界中事物的元素
</li><li> <b>表达式（Expressions）：</b> 形成复杂描述的实体的组合
</li></ul>
<p>
  <span id="a_Ontology"> </span>
  尽管 OWL 2 旨在获取并存储知识，但 OWL 2 所能表示的“知识”显然不足以涵盖意识领域中知识的各个方面。
  OWL 可以被认为是用于某些特定人类知识的强大且通用的建模语言。
  建模的结果被称为<i>本体</i>——一个能避免与“模型”一词混淆的术语，
  因为在知识呈现领域中后者通常拥有完全不同的意义。
</p>
<p>
  为了能显式地表达知识，我们可以将知识视为由许多被称为<i>陈述</i>或<i>命题</i>的基本元素组成的整体。
  “现在在下雨”或者“所有人都会死”这样的陈述就是命题的典例。
  没错，每个 OWL&nbsp;2 本体本质上都是这样“知识片段”的集合。
  在 OWL&nbsp;2 本体中做出的陈述被称为<i>公理</i>，并且本体认为构成自身的公理均为真。
  一般来说，根据事物的具体情况，OWL 陈述可能为真或假，
  这将它们从下面描述的<i>实体</i>和<i>表达式</i>区分开来。
</p>
<p>
  当人思考的时候，他们从自己的知识中得出结果。
  OWL 的一个重要特性就是它能利用自身知识来模仿人类智能的这一方面。
  但是，通常情况下，一个陈述是其他多个陈述的结果，这是什么意思？
  本质上，这意味着当其他陈述为真时，该陈述总为真。
  以 OWL 的角度来看：如果一组陈述<i>A</i>能够推出陈述<i>a</i>，且在某种情况下<i>A</i>
  中的所有陈述为真，则该情况下陈述<i>a</i>必定为真。
  此外，一组陈述可能是<i>一致的</i>（也就是说，存在一种情况，使得这一组陈述中的所有陈述均为真），
  也有可能是<i>不一致的</i>（使这一组陈述中的所有陈述均为真的情况不存在）。
  OWL 的正式语义表明，在任何情况下，总有一组特定的 OWL 陈述为真。
</p><p>
  OWL 工具——推理器，能够自动计算结果。
  本体的公理之间的相互作用可能很微妙且难以理解。
  这既是 OWL&nbsp;2 的优势，也是其劣势。
  优势在于 OWL&nbsp;2 工具能够发现人们可能难以发现的信息。
  这允许知识工程师能够更直接地建模，也能让系统能够在建模过程中提供有用的反馈和详细的分析信息。
  劣势则是因为，人们很难立刻预见不同组合中各种结构能产生怎样的效果。
  工具改善了这一情况，但成功的知识工程仍然需要一些训练和经验。
</p>
<p>
  进一步观察 OWL 中的陈述，我们发现他们很少是“不可分割”的，而是经常有可以被显式呈现的内部结构。
  它们通常指向世界中的某些对象，并且会对它们分类（比如“Mary是女性”），
  或者描述它们之间的联系（比如“John和Mary结婚了”）。
  所有陈述中的不可再分的部分，不论是对象（John，Mary）、类别（女性）或者关系（结婚），被称为<i>实体</i>。
  在 OWL&nbsp;2 中，我们将对象表示为<i>个体（individuals）</i>，
  类别表示为<i>类（classes）</i>，关系表示为<i>属性（properties）</i>。
  在 OWL 2 中属性被进一步细分。<i>对象属性（object properties）</i>使对象与对象之间产生联系（比如某人及其伴侣），
  而<i>数据属性（datatype properties）</i>用于赋予对象数据值（如某人的年龄）。
  <i>注释属性（annotation properties）</i>用于储存本体本身的（一些）信息
  （比如某个公理的作者和其创建日期）而非本体的兴趣域。
</p>
<p>
  OWL 的核心特性之一是实体的名称可以使用<i>构造器</i>来组合成<i>表达式</i>。
  最简单的例子就是，原子类“女性”和“教授”可以被组合起来描述”女教授“这一类。
  后者可以用一个 OWL 类表达式来描述，自然也可以用于陈述或其他表达式中。
  这样，表达式可以被视为由自身结构定义的新实体。
  在 OWL 中，不同类型的实体所使用的构造器之间有很大不同。
  类的描述语言十分丰富且复杂，而属性的描述语言则不那么丰富。
  这些区别的产生有其历史原因，还有一些技术原因。
</p>
<a id="Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them" name="Classes.2C_Properties.2C_and_Individuals_.E2.80.93_And_Basic_Modeling_With_Them"></a><h2> <span class="mw-headline">4 类, 属性, 个体 —— 还有使用他们来建模</span></h2>
<p>
  在完成这些基本介绍后，我们现在来接触使用 OWL 2 来建模的细节。
  在接下来的几节里，我们将介绍 OWL 2 提供的核心建模特性，提供示例并给出一些如何使用它们的建议。
  我们将从在几乎任何建模语言中都存在的基本特性开始，向更高级的结构进发。
</p>
<p>
  下面我们将使用 OWL 来表示一个家庭。
  请注意，我们并非想让这个例子代表 OWL 应该被应用的领域，也不认为这是一个良好的使用 OWL 建模的范例，
  且不认为这能正确表示一个事实上复杂多变且会因文化环境不同而存在各种差异的家庭。
  我们只是想让这个它成为一个能展示 OWL 多种特性的简单示例。
</p>
<a id="Classes_and_Instances" name="Classes_and_Instances"></a><h3> <span class="mw-headline">4.1 类和实例</span></h3>
<p><span id="a_ClassAssertion"> </span>
  我们用介绍我们谈论的人作为本节开头。我们可以用下面的方式来介绍一个人：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(&nbsp;:Person&nbsp;:Mary ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;Person rdf:about="Mary"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Mary rdf:type&nbsp;:Person .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: Mary
   Types: Person
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
    &lt;Class IRI="Person"/&gt;
    &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><br>
  这个陈述提及了个体Mary，并声称这个个体是人。
  更技术上说，<i>是人</i>意味着Mary属于（或者说，是其成员；或者更技术一点，是其实例）<i>人</i>这一个类。
  通常来说，类将有共同性质的个体包含在一起以便指代他们。所以，类的本质是个体的集合。
  在建模领域，类通常用来表示人类思维概念中一些对象的集合，比如<i>人</i>和<i>女人</i>。
  因此，我们可以使用“Mary是‘女人’这个类的实例”这样的陈述来表示Mary是女人：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(&nbsp;:Woman&nbsp;:Mary ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;Woman rdf:about="Mary"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Mary rdf:type&nbsp;:Woman .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: Mary
   Types: Woman
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
    &lt;Class IRI="Woman"/&gt;
    &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p>
  由此，我们可以很明显地看出，类的成员资格是非排它的：
  对个体归类存在多种标准（比如性别、年龄、鞋子尺码等），
  一个个体也可以同时属于多个类。
</p>
<a id="Class_Hierarchies" name="Class_Hierarchies"></a><h3> <span class="mw-headline">4.2 类的层次结构</span></h3>
<p>
  在前面的一节里，我们谈及了两个类：包括所有人的类和包括所有女人的类。
  对于人类读者来说，很自然能看出这两个类存在特殊联系：“人”的概念比“女人”更加广泛。
  也就是说，当我们知道一个个体是女人的时候，那她一定是人。
  然而，这种关系不能从“人”和“女人”的符号本身中被推断出来，
  而是从一个人关于这个世界的背景知识和这两个符号的用法中推断出来。
  所以，为了能让计算机系统能够得出预期的结论，我们必须向其明确指出这样的联系。
 <span id="a_SubClassOf"> </span>在 OWL 2 中，可以通过声明“子类公理”来实现：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf(&nbsp;:Woman&nbsp;:Person )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Woman"&gt;
   &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Woman rdfs:subClassOf&nbsp;:Person .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Woman
   SubClassOf: Person
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Woman"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>
  在本体中出现的这条公理让推理器能够推测，对于每一个是“女人”这个类的实例，
  其同样是“人”这个类的实例。经验告诉我们，当“每个A都可以是B”为真时，A便可以成为B的子类。
</p>
<p>
  在本体建模中使用子类陈述是很常见的，它不仅用于声明类之间的包含关系，
  还能通过确定一个兴趣域内所有类一般化的联系来描述一整个<i>类的层次结构</i>。
  假设我们想要声明所有的母亲都是女人：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf(&nbsp;:Mother&nbsp;:Woman )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Mother"&gt;
   &lt;rdfs:subClassOf rdf:resource="Woman"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Mother rdfs:subClassOf&nbsp;:Woman .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Mother
   SubClassOf: Woman
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Mother"/&gt;
   &lt;Class IRI="Woman"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>
  这样推理器不仅能为所有是“母亲”类的实例推断出她是”女人“类的实例，而且也能推断出，
  她也是“人”这一类的实例——正好是我们想要的结果。
  技术上说，这意味着类之间的子类关系是<i>可传递的</i>(transitive)。
  除此之外，这样的关系还是<i>反身的</i>（reflexive），
  也就是说，每个类都是自己的子类——这很符合直觉，比如每个人都是人。
</p><p><span id="a_EquivalentClasses"> </span>
</p><p>
  在我们自己的词汇中，不同的“类”可能指向同一个集合。由此，OWL 提供了使得两个类在语义上等价的机制。
  比如，当我们可互换地使用“人”（Person）和“人类”（Human）的时候，意味着“人”类的实例也是“人类”类的实例，且反之亦然。
  当两个类包含完全相同的个体时，它们就被认为是完全相等的。
  下面这个例子声明“人”类与“人类”类等价：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(&nbsp;:Person&nbsp;:Human )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;owl:equivalentClass rdf:resource="Human"/&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Person owl:equivalentClass&nbsp;:Human .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Person
   EquivalentTo: Human
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Person"/&gt;
   &lt;Class IRI="Human"/&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  声明“人”和“人类”等价意味着“人”是“人类”的子类，“人类”也是“人”的子类。
</p>
<a id="Class_Disjointness" name="Class_Disjointness"></a><h3> <span class="mw-headline">4.3 类的不交性</span></h3>
<p><span id="a_DisjointClasses"> </span>
  在4.1节中，我们说一个个体可以是多个类的实例。然而，在某些情况下，类的成员资格是排他的。
  对于“男人”和“女人”类，我们知道，没有任何个体能同时是这两个类的实例（为了方便起见，我们不讨论正好在生理边界上的那些例子）。
  这种类之间的“不兼容关系”被称为<i>（类的）不交性</i>（disjointness）。
  与“女人”是“人”的子类这一关系一样，类之间的不交来自于我们的背景知识，
  因而同样必须显示指出这样的关系才能让推理器利用这种关系。
  这可以通过下面的例子来实现：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DisjointClasses(&nbsp;:Woman&nbsp;:Man )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Woman"/&gt;
     &lt;owl:Class rdf:about="Man"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> []  rdf:type     owl:AllDisjointClasses&nbsp;;
     owl:members  (&nbsp;:Woman &nbsp;:Man ) . 
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> DisjointClasses: Woman, Man
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DisjointClasses&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Man"/&gt;
 &lt;/DisjointClasses&gt;
</pre>
</div>
<p>
  在实践中，不交声明经常被遗漏或忽略。一种理由是，从直觉上说，除非额外声明，一个类与其他类都应该是不交的。
  这样的结果是，许多有价值的结论可能会丢失。在我们给出的示例中，不交公理是推断Mary不是男人所必须的。
  更进一步，如果给出了这样的不交公理，推理器便可以推测出“母亲”和“男人”的不交性。
</p>
<a id="Object_Properties" name="Object_Properties"></a><h3> <span class="mw-headline">4.4 对象属性</span></h3>
<p>
  在接下来的几节里，我们将着眼与描述单个个体、它们的类的成员资格，和类怎样通过它们的实例来建立联系。
  在更多情况下，一个本体也包含某个个体与其他个体之间的关系。
  下面的关系是描述一个家庭的关键。
<span id="a_ObjectPropertyAssertion"> </span>
  我们首先声明Mary是John的妻子。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:John&nbsp;:Mary )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;hasWife rdf:resource="Mary"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John&nbsp;:hasWife&nbsp;:Mary .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Facts: hasWife Mary
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/ObjectPropertyAssertion&gt;
</pre>
</div>
<p>
  像这样，描述个体之间联系的实体——像上述例子中的hasWife（"有妻子是..."），被称为<i>属性</i>。
</p>
<p>
  需要注意的是，个体在签名中的顺序是很重要的。“Mary是John的妻子”可能为真，但“John是Mary的妻子”则显然不是。
  的确，这是建模错误的一个常见来源，但我们可以通过使用仅有一种符合逻辑的阅读方式的属性名来避免。
  在使用名词的情况下（比如妻子"wife"），这样明确的属性名可能带有"of"（“是...的”）或者"has"（“有...”），
  如"wifeOf"（“是...的妻子”）或者"hasWife"(“有妻子是...”)。
  而对于动词（比如"to love"，“爱”），可以使用其变形("loves"，喜爱，主动形式)或者带有"by"的被动形式（"lovedBy"，“被...爱”）来消除歧义。
</p><p><span id="a_NegativeObjectPropertyAssertion"> </span>
  我们也可以通过属性来声明两个个体没有某种关系。
  下方的示例声明Mary不是Bill的妻子。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> NegativeObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:Bill&nbsp;:Mary )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasWife"/&gt;
   &lt;owl:targetIndividual rdf:resource="Mary"/&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Bill&nbsp;;
     owl:assertionProperty &nbsp;:hasWife&nbsp;;
     owl:targetIndividual  &nbsp;:Mary .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: Bill
   Facts: not hasWife Mary
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;NegativeObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
 &lt;/NegativeObjectPropertyAssertion&gt;
</pre>
</div>
<p>
  否定属性断言是了声明某些事物为假的专用方式。
  因为 OWL 遵从开放世界假设：除非特别声明，任何事物都可能为真，
  所以这样的信息就显得尤为重要。
</p>
<a id="Property_Hierarchies" name="Property_Hierarchies"></a><h3> <span class="mw-headline">4.5 属性的层次结构</span></h3>
<p><span id="a_topObjectProperty"> </span>
<span id="a_bottomObjectProperty"> </span>
<span id="a_topDataProperty"> </span>
<span id="a_bottomDataProperty"> </span>
</p><p><span id="a_SubObjectPropertyOf"> </span>
  在4.2节中我们了解到一个类的成员身份可能暗示另一个类的成员身份。
  同理，属性也可以：当已知B是A的妻子时，B也是A的伴侣（注意，反过来并不成立）。
  OWL 允许以下面这种方式做出这样的声明：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubObjectPropertyOf(&nbsp;:hasWife&nbsp;:hasSpouse )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
   &lt;rdfs:subPropertyOf rdf:resource="hasSpouse"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasWife rdfs:subPropertyOf&nbsp;:hasSpouse .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasWife
   SubPropertyOf: hasSpouse
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubObjectPropertyOf&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<p><span id="a_SubDataPropertyOf"></span><span id="a_SubAnnotationPropertyOf"></span>
<span id="a_EquivalentObjectProperties"></span><span id="a_EquivalentDataProperties"></span>
  对于声明等价属性，也有语法上的快捷方式，这一点与等价类类似。
</p>
<a id="Domain_and_Range_Restrictions" name="Domain_and_Range_Restrictions"></a><h3> 
  <span class="mw-headline">4.6 域和范围限制</span></h3>
<p><span id="a_ObjectPropertyDomain"> </span><span id="a_ObjectPropertyRange"> </span>
  通常情况下，两个个体通过某些属性产生的联系能够进一步得出与这两个个体有关的结论。
  更具体一点，比如推测类的成员身份。例如，声明“B是A的妻子”隐含着B是女人而A是男人。
  所以在某种程度上，两个个体通过某些属性产生的联系携带着关于这两个个体的隐藏信息。
  在我们给出的例子里，这样隐藏的信息是类的成员身份。
  OWL 提供了声明这种关系的方式：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ObjectPropertyDomain(&nbsp;:hasWife&nbsp;:Man ) 
 ObjectPropertyRange(&nbsp;:hasWife&nbsp;:Woman ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
   &lt;rdfs:domain rdf:resource="Man"/&gt;
   &lt;rdfs:range rdf:resource="Woman"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasWife rdfs:domain&nbsp;:Man&nbsp;;
          rdfs:range &nbsp;:Woman .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasWife
   Domain: Man
   Range: Woman
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ObjectPropertyDomain&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;Class IRI="Man"/&gt;
 &lt;/ObjectPropertyDomain&gt;
 &lt;ObjectPropertyRange&gt;
   &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;Class IRI="Woman"/&gt;
 &lt;/ObjectPropertyRange&gt;
</pre>
</div>
<p>
  给出这两个公理，例如，Sasha通过hasWife与Hillary联系起来，推理器就能够推出
  Sasha是男人且Hillary是女人。
</p>
<a id="Equality_and_Inequality_of_Individuals" name="Equality_and_Inequality_of_Individuals"></a><h3> <span class="mw-headline">4.7 个体间的相等和不等</span></h3>
<p>
  需要引起注意的是，从我们目前给出的信息来看，我们可以推测John和Mary不是同一个个体，因为他们分属于“男人”和“女人”这两个不交类的实例。
  然而，如果我们再添加一位家庭成员的信息，比如Bill,并且声明他是男人，那目前为止，还不存在John和Bill不是同一个个体的声明。
  OWL 并不接受因为名字不同就认为是不同个体的假设。
  （这种“唯一名称假设”的缺失特别适用于语义Web应用，其中的不同名字可能被不同组织用来指代同一个个体。）
  <span id="a_DifferentIndividuals"> </span>
  所以，如果想要排除掉John和Bill是同一个人的可能性，我们必须像下面这样显示指出：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DifferentIndividuals(&nbsp;:John&nbsp;:Bill )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;owl:differentFrom rdf:resource="Bill"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John owl:differentFrom&nbsp;:Bill .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John 
   DifferentFrom: Bill 
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DifferentIndividuals&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
 &lt;/DifferentIndividuals&gt;
</pre>
</div>
<p><span id="a_SameIndividual"> </span>
  同样，我们也可以声明两个名字指向（可以推测出是）同一个个体。
  比如，我们可以声明James和Jim是同一个个体：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SameIndividual(&nbsp;:James&nbsp;:Jim )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="James"&gt;
   &lt;owl:sameAs rdf:resource="Jim"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:James owl:sameAs&nbsp;:Jim.
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: James
   SameAs: Jim
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="James"/&gt;
   &lt;NamedIndividual IRI="Jim"/&gt;
 &lt;/SameIndividual&gt;
</pre>
</div>
<p>
  这允许推理器能够推测出James的任何信息对于Jim同样适用。
</p>
<a id="Datatypes" name="Datatypes"></a><h3> <span class="mw-headline">4.8  数据类型 </span></h3>
<p>
  目前为止，我们已经了解了如何通过类的成员身份和它们与其他个体之间的联系来描述一个个体。
  然而在许多情况下，个体必须使用数据值来描述。想想一个人的生日日期、他的年龄、他的电子邮箱地址等等。
  为了达成这一目的，OWL 提供了另一种属性，称为 <span id="a_DataProperty"><i>数据属性</i>（Datatype properties</span>）。
  这些属性将个体和数据值联系起来（而不是与其他个体），可以使用在XML格式[<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>]中使用的很多数据类型。
<span id="a_DataPropertyAssertion"> </span>
  下面是使用数据属性的一个示例。它声明John的年龄是51（岁）。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DataPropertyAssertion(&nbsp;:hasAge&nbsp;:John "51"^^xsd:integer )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;Person rdf:about="John"&gt;
   &lt;hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;51&lt;/hasAge&gt;
 &lt;/Person&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John &nbsp;:hasAge  51 .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Facts: hasAge "51"^^xsd:integer
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DataPropertyAssertion&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;51&lt;/Literal&gt;
 &lt;/DataPropertyAssertion&gt;
</pre>
</div>
<p><span id="a_NegativeDataPropertyAssertion"> </span>
  同理，我们也可以声称Jack的年龄<i>不是</i>53（岁）。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> NegativeDataPropertyAssertion(&nbsp;:hasAge&nbsp;:Jack "53"^^xsd:integer )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Jack"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasAge"/&gt;
   &lt;owl:targetValue rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;
     53
   &lt;/owl:targetValue&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Jack&nbsp;;
     owl:assertionProperty &nbsp;:hasAge&nbsp;;
     owl:targetValue        53 .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: Jack
   Facts: not hasAge "53"^^xsd:integer
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;NegativeDataPropertyAssertion&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;53&lt;/Literal&gt;
 &lt;/NegativeDataPropertyAssertion&gt;
</pre>
</div>
<p><span id="a_DataPropertyDomain"> </span><span id="a_DataPropertyRange"> </span>
  域和范围限制也也适用于数据属性。不过，在这种情况下，范围将是一个数据类型而不是类。
  下面的示例声明属性hasAge只能将非负数的年龄与人联系起来。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DataPropertyDomain(&nbsp;:hasAge&nbsp;:Person ) 
 DataPropertyRange(&nbsp;:hasAge xsd:nonNegativeInteger ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
   &lt;rdfs:domain rdf:resource="Person"/&gt;
   &lt;rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"/&gt;
 &lt;/owl:DatatypeProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasAge  rdfs:domain &nbsp;:Person&nbsp;;
          rdfs:range   xsd:nonNegativeInteger .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> DataProperty: hasAge
   Domain: Person
   Range:  xsd:nonNegativeInteger
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DataPropertyDomain&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/DataPropertyDomain&gt;
 &lt;DataPropertyRange&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"/&gt;
 &lt;/DataPropertyRange&gt;
</pre>
</div>
<p>
  到这里我们需要指出一个常见错误，它在使用属性的域和范围限制的时候很容易出现。
  在我们刚刚给出的示例中，我们声明hasAge属性只适用于将人与非负数整数联系起来。
  假设我们也声明了Felix是“猫”的实例且使用hasAge将整数“9”与它联系起来，
  那从所有的信息中可以推出Felix也是“人”的实例，这可能并不是我们想要的。
  这将导致一个常见的建模错误：注意，一个域（或者范围）限制并不是知识上的约束，而为了让
  推理器能够进一步得出更多信息。如果我们声明——像例子中的那样——年龄只适用于“人”，那
  所有我们赋予年龄的个体都自动成为“人”的实例。
</p>
<a id="Advanced_Class_Relationships" name="Advanced_Class_Relationships"></a><h2> <span class="mw-headline">5 类关系进阶</span></h2>
<p>
  在前面的章节里，我们将类视为某些带有名字的“不透明的”东西。我们使用它们来
  表示个体的特征，并用子类或者不交声明来将它们与其他类联系起来。
</p><p>
  我们现在将展示如何使用带有名字的类、属性，和个体作为定义新类的基础。
</p>
<a id="Complex_Classes" name="Complex_Classes"></a><h3> <span class="mw-headline">5.1 复合类</span></h3>
<p>
  使用我们先前介绍的语言特性，我们已经可以定义简单的本体。
  为了表示更复杂的知识，OWL 为类提供了逻辑构造器。
  具体地说，OWL 在语言层面提供了逻辑与、或和非。
  它们对应的 OWL 术语来自于集合论：<i>(类的)交集</i>、<i>并集</i>和<i>补集</i>。
  这些构造器将原子类——比如带名字的类——组合成复合类。
</p><p><span id="a_ObjectIntersectionOf"> </span>
  两个类的<i>交集</i>包含且仅包含是同时是这两个类的实例的个体。
  下面的示例声明“母亲”类包含同时是“女人”和“父母”的实例的对象：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Mother 
   ObjectIntersectionOf(&nbsp;:Woman&nbsp;:Parent )
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Mother"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Woman"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Mother  owl:equivalentClass  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Woman&nbsp;:Parent ) 
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Mother
   EquivalentTo: Woman and Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Mother"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  从上述声明中能得出的一个结论是，“母亲”的实例也是“父母”的实例。
</p><p><span id="a_ObjectUnionOf"> </span>
  两个类的<i>幷集</i>包括且仅包括至少属于其中一个类的所有实例。
  因此，我们可以把“父母”描述为“父亲”和“母亲”的并集：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Parent 
   ObjectUnionOf(&nbsp;:Mother&nbsp;:Father )
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:unionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Mother"/&gt;
         &lt;owl:Class rdf:about="Father"/&gt;
       &lt;/owl:unionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Parent  owl:equivalentClass  [
   rdf:type     owl:Class&nbsp;;
   owl:unionOf  (&nbsp;:Mother&nbsp;:Father )
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Parent
   EquivalentTo: Mother or Father
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectUnionOf&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="Father"/&gt;
   &lt;/ObjectUnionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_ObjectComplementOf"> </span>
  一个类的<i>补集</i>对应着一种逻辑上的否定：它的包含且仅包含是那些不属于这个类的实例。
  下面对无孩子的人的定义使用到类的补集，同时表明类构造器可以嵌套使用：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:ChildlessPerson 
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(&nbsp;:Parent )
   )
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="ChildlessPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf rdf:resource="Parent"/&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:ChildlessPerson  owl:equivalentClass  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person  
                         [ rdf:type          owl:Class&nbsp;;
                           owl:complementOf &nbsp;:Parent ] ) 
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: ChildlessPerson
   EquivalentTo: Person and not Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;ObjectComplementOf&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  上述所有示例展示了如何使用类构造器来从其他类的组合定义一个新类。
  但是，当然，类构造器可以和子类声明一起使用来定义成为一个类成员的必要不充分条件。
  下面的语句指出每个“祖父”都属于“男人”和“父母”（然而反过来并不一定成立）：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf( 
  &nbsp;:Grandfather 
   ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Grandfather"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Man"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Grandfather  rdfs:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Grandfather
   SubClassOf: Man and Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Grandfather"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>
  通常来说，在使用有名字的类地方都可以使用复合类，类相关的断言也可以。
  下面的示例展示了这一点，其断言Jack是“人”的实例而不是“父母”的实例：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(&nbsp;:Parent )
   ) 
  &nbsp;:Jack
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="Jack"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf  rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf rdf:resource="Parent"/&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Jack  rdf:type  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person  
                         [ rdf:type          owl:Class&nbsp;;
                           owl:complementOf &nbsp;:Parent     ]
                       )
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: Jack
   Types: Person and not Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectIntersectionOf&gt;
    &lt;Class IRI="Person"/&gt;
    &lt;ObjectComplementOf&gt;
      &lt;Class IRI="Parent"/&gt;
    &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
   &lt;NamedIndividual IRI="Jack"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<a id="Property_Restrictions" name="Property_Restrictions"></a><h3> <span class="mw-headline">5.2 属性限制</span></h3>
<p>
  属性限制构造器为复合类提供了另一种基于逻辑的构造器。
  正如名字显示的，对属性做出限制需要使用与属性有关的构造器。
</p><p><span id="a_ObjectSomeValuesFrom"> </span>
  一种属性限制被称为<i>存在量化</i>（existential quantification）。
  它将那些通过特定属性与其他个体产生联系的个体归为一类，且与其产生联系的个体中存在属于特定的类的个体。
  我们最好通过例子来解释它的效果，就像下面的例子，它定义“父母”类的实例是那些有通过hasChild属性与其他个体联系起来的个体：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Parent 
   ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:Person )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Parent  owl:equivalentClass  [
   rdf:type            owl:Restriction&nbsp;;
   owl:onProperty     &nbsp;:hasChild&nbsp;;
   owl:someValuesFrom &nbsp;:Person
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Parent
   EquivalentTo: hasChild some Person
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectSomeValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/ObjectSomeValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  这里认为每个“父母”的实例都应至少有一个孩子，并且他的孩子是“人”的实例。
  这对捕捉<i>不完整</i>知识有所帮助。比如，Sally告诉我们Bob是一位父母，这样我们
  就能推测出他至少有一个孩子，即使我们还不知道他（们）的名字。
  在自然语言中使用到存在量词的提示是“几个”“之一”。
</p><p><span id="a_ObjectAllValuesFrom"> </span>
  另一种属性限制被称为<i>全称量化</i>。
  它将那些有通过特定属性与其他个体产生联系的个体归为一类，且与其产生联系的个体都属于特定的类。
  我们可以使用下面的语句表示仅当一个人的所有孩子都是快乐的人时，他才是一个快乐的人。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:HappyPerson 
   ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:Class rdf:about="HappyPerson"/&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:HappyPerson  rdf:type    owl:Class&nbsp;;
     owl:equivalentClass  [
       rdf:type           owl:Restriction&nbsp;;
       owl:onProperty    &nbsp;:hasChild&nbsp;;
       owl:allValuesFrom &nbsp;:Happy
     ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: HappyPerson
   EquivalentTo: hasChild only HappyPerson
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="HappyPerson"/&gt;
   &lt;ObjectAllValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Happy"/&gt;
   &lt;/ObjectAllValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  这个示例同样展示了 OWL 语句可以自我引用：类 HappyPerson （快乐的人）在等价语句中的两段都有使用。
</p><p>
  使用属性限制可能会给“建模新手”带来一些概念上的混淆。
  经验告诉我们，当将使用自然语言做出的声明翻译成逻辑公理时，存在量化更常出现。
  自然语言中的全称量化通常使用“只有”“仅”和“除...外都不”。
</p><p>
  对于全称量化，常常存在着一个误解。
  以上面的幸福公理为例，直觉告诉我们，为了让一个“人”感到幸福，他至少需要一个孩子，而且必须是快乐的孩子。
  但有人可能认为“任何没有 hasChild 属性的个体都满足‘任意hasChild’类的成员（因为这一属性并不存在）”，
  并推理出没有孩子的人也是幸福的，这是错误的。
  为了表达前面提到的符合直觉的推断，幸福公理需要这样理解：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:HappyPerson 
   ObjectIntersectionOf(
     ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
     ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
   )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:Class rdf:about="HappyPerson"/&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
         &lt;/owl:Restriction&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:someValuesFrom rdf:resource="HappyPerson"/&gt;
         &lt;/owl:Restriction&gt;
        &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:HappyPerson  rdf:type    owl:Class&nbsp;;
     owl:equivalentClass  [
       rdf:type            owl:Class&nbsp;;
       owl:intersectionOf  ( [ rdf:type            owl:Restriction&nbsp;;
                               owl:onProperty     &nbsp;:hasChild&nbsp;;
                               owl:allValuesFrom  &nbsp;:Happy            ]
                             [ rdf:type            owl:Restriction&nbsp;;
                               owl:onProperty     &nbsp;:hasChild&nbsp;;
                               owl:someValuesFrom &nbsp;:Happy            ]
                           )
     ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: HappyPerson
   EquivalentTo: hasChild only HappyPerson and hasChild some HappyPerson
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="HappyPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="HappyPerson"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="HappyPerson"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  该示例也展示了属性限制声明可以与复合类嵌套使用。
</p><p><span id="a_ObjectHasValue"> </span>
  属性限制声明同样可以描述与某个特定个体有联系的一类个体。
  比如，我们可以这样定义 “John 的孩子”类：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses( 
  &nbsp;:JohnsChildren 
   ObjectHasValue(&nbsp;:hasParent&nbsp;:John )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="JohnsChildren"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="hasParent"/&gt;
       &lt;owl:hasValue rdf:resource="John"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:JohnsChildren  owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:hasParent&nbsp;;
   owl:hasValue   &nbsp;:John
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: JohnsChildren
   EquivalentTo: hasParent value John
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="JohnsChildren"/&gt;
   &lt;ObjectHasValue&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ObjectHasValue&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_ObjectHasSelf"> </span>
  作为个体与个体通过属性连接的特例，一个个体可能通过属性与其本身建立联系。
  下面的例子声明了所有自恋者都爱他们自己。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:NarcisticPerson 
   ObjectHasSelf(&nbsp;:loves ) 
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="NarcisticPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="loves"/&gt;
       &lt;owl:hasSelf rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;
         true
       &lt;/owl:hasSelf&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:NarcisticPerson owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:loves&nbsp;;
   owl:hasSelf     "true"^^xsd:boolean .
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: NarcisticPerson
   EquivalentTo: loves Self
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;ObjectHasSelf&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/ObjectHasSelf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<a id="Property_Cardinality_Restrictions" name="Property_Cardinality_Restrictions"></a><h3> <span class="mw-headline">5.3 属性的数值限制</span></h3>
<p>
  使用全称量化，我们可以描述某人所有的孩子，而存在量化让我们可以描述其中的某一个或几个。
  然而，我们可能想在限制声明中明确受影响的个体数量。
  我们的确可以根据孩子的数量来构造一系列类。
  <span id="a_ObjectMaxCardinalityQualified"> </span>
  下面的例子声明 John 有最多四个是父母的孩子：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(
   ObjectMaxCardinality( 4&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:maxQualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         4
       &lt;/owl:maxQualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                     owl:Restriction&nbsp;;
   owl:maxQualifiedCardinality  "4"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty              &nbsp;:hasChild&nbsp;;
   owl:onClass                 &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Types: hasChild max 4 Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectMaxCardinality cardinality="4"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectMaxCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p>
  注意：这样的声明允许 John 拥有任意个不是父母的孩子。
</p><p><span id="a_ObjectMinCardinalityQualified"> </span>
  同理，也可以通过声明 John 属于一个有至少两个是父母的孩子的类来确定一个最小值：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(
   ObjectMinCardinality( 2&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:minQualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         2
       &lt;/owl:minQualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                     owl:Restriction&nbsp;;
   owl:minQualifiedCardinality  "2"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty              &nbsp;:hasChild&nbsp;;
   owl:onClass                 &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Types: hasChild min 2 Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectMinCardinality cardinality="2"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectMinCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><span id="a_ObjectExactCardinalityQualified"> </span>
  如果我们恰好知道 John 有多少是父母的孩子，我们也可以这样声明：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion( 
   ObjectExactCardinality( 3&nbsp;:hasChild&nbsp;:Parent ) 
  &nbsp;:John
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:qualifiedCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         3
       &lt;/owl:qualifiedCardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;owl:onClass rdf:resource="Parent"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type                  owl:Restriction&nbsp;;
   owl:qualifiedCardinality  "3"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty           &nbsp;:hasChild&nbsp;;
   owl:onClass              &nbsp;:Parent
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Types: hasChild exactly 3 Parent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectExactCardinality cardinality="3"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectExactCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<p><span id="a_ObjectExactCardinality"> </span>
  在数值限制声明中，提供一个类不是必须的。
  如果我们只想对 John 的孩子数量做出限制，我们可以这样写：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ClassAssertion(
   ObjectExactCardinality( 5&nbsp;:hasChild ) 
  &nbsp;:John
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;rdf:type&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:cardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
         5
       &lt;/owl:cardinality&gt;
       &lt;owl:onProperty rdf:resource="hasChild"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/rdf:type&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John  rdf:type  [
   rdf:type         owl:Restriction&nbsp;;
   owl:cardinality  "5"^^xsd:nonNegativeInteger&nbsp;;
   owl:onProperty  &nbsp;:hasChild
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
   Types: hasChild exactly 5
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ClassAssertion&gt;
   &lt;ObjectExactCardinality cardinality="5"&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/ObjectExactCardinality&gt;
   &lt;NamedIndividual IRI="John"/&gt;
 &lt;/ClassAssertion&gt;
</pre>
</div>
<a id="Enumeration_of_Individuals" name="Enumeration_of_Individuals"></a><h3> <span class="mw-headline">5.4 枚举个体来定义类</span></h3>
<p><span id="a_ObjectOneOf"> </span>
  枚举一个类的所有实例是定义这个类的一个非常直接的方法。
  我们可以为所有参加生日派对的客人创建一个类：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:MyBirthdayGuests
   ObjectOneOf(&nbsp;:Bill&nbsp;:John&nbsp;:Mary)
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="MyBirthdayGuests"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Class&gt;
       &lt;owl:oneOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="Bill"/&gt;
         &lt;rdf:Description rdf:about="John"/&gt;
         &lt;rdf:Description rdf:about="Mary"/&gt;
       &lt;/owl:oneOf&gt;
     &lt;/owl:Class&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:MyBirthdayGuests  owl:equivalentClass  [
   rdf:type   owl:Class&nbsp;;
   owl:oneOf  (&nbsp;:Bill &nbsp;:John &nbsp;:Mary )
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: MyBirthdayGuests
   EquivalentTo: { Bill, John, Mary }
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="MyBirthdayGuests"/&gt;
   &lt;ObjectOneOf&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ObjectOneOf&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p>
  注意，这一公理不仅确定了 Bill，John 和 Mary 的成员身份，像 4.1 节中介绍的那样，
  还声明这三人是 MyBirthdayGuests 类仅有的成员。
  因此，这样定义的类有时被称为<i>封闭的类</i>，或可枚举集合。
  如果我们现在声明 Jeff 也是这个类的实例，这将表明 Jeff 和上面三个人中的某一人是同一人。
</p>
<a id="Advanced_Use_of_Properties" name="Advanced_Use_of_Properties"></a><h2> <span class="mw-headline">6 属性的进阶用法</span></h2>
<p>
  目前为止，类和属性仅在类表达式中作为基本元素使用。
  接下来，我们将认识 OWL 2 中属性在建模方面的其他能力。
</p>
<a id="Property_Characteristics" name="Property_Characteristics"></a><h3> <span class="mw-headline">6.1 Property Characteristics</span></h3>
<p><span id="a_InverseObjectProperties"> </span>
  有时可以通过改变一个属性的方向来取得另一个属性，也就是翻转。
  例如，属性 hasParent （有父母是...）可以定义为 hasChild （有孩子是...）的翻转属性。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> InverseObjectProperties(&nbsp;:hasParent&nbsp;:hasChild ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:ObjectProperty rdf:about="hasParent"&gt;
   &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasParent owl:inverseOf&nbsp;:hasChild .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasParent
   InverseOf: hasChild
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;InverseObjectProperties&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
 &lt;/InverseObjectProperties&gt;
</pre>
</div>
<p>
  这让我们可以推测，对于任意两个个体 A 和 B，当 A 使用 hasChild 属性与 B 建立联系时，
  B 自动通过 hasParent 属性与 A 建立联系。
  <span id="a_ObjectInverseOf"> </span>
  不过，如果我们想要，比如在类表达式中，使用一个属性的翻转，我们可以直接使用它而不创建一个新的类。
  在 Orphan （孤儿）类的定义中，除了使用刚刚定义的 hasParent 属性，我们也可以直接翻转 hasChild:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> EquivalentClasses(
  &nbsp;:Orphan
   ObjectAllValuesFrom(
     ObjectInverseOf(&nbsp;:hasChild )
    &nbsp;:Dead
   )
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Orphan"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty&gt;
         &lt;owl:ObjectProperty&gt;
           &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
         &lt;/owl:ObjectProperty&gt;
       &lt;/owl:onProperty&gt;
       &lt;owl:allValuesFrom rdf:resource="Dead"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Orphan  owl:equivalentClass  [
   rdf:type           owl:Restriction&nbsp;;
   owl:onProperty     [ owl:inverseOf &nbsp;:hasChild ]&nbsp;;
   owl:allValuesFrom &nbsp;:Dead 
 ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Orphan
   EquivalentTo: inverse hasChild only Dead
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;EquivalentClasses&gt;
   &lt;Class IRI="Orphan"/&gt;
   &lt;ObjectAllValuesFrom&gt;
     &lt;ObjectInverseOf&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectInverseOf&gt;
     &lt;Class IRI="Dead"/&gt;
   &lt;/ObjectAllValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
</pre>
</div>
<p><span id="a_SymmetricObjectProperty"> </span>
  在某些情况下，一个属性和其翻转等价，或者说，这个属性的方向无关紧要。
  比如，hasSpouse 将 A 与 B 连接等价于将 B 与 A 连接。
  有着这样特征的属性被认为是<i>对称的</i>，可以这样表示：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SymmetricObjectProperty(&nbsp;:hasSpouse ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:SymmetricProperty rdf:about="hasSpouse"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasSpouse  rdf:type  owl:SymmetricProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasSpouse
   Characteristics: Symmetric
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SymmetricObjectProperty&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/SymmetricObjectProperty&gt;
</pre>
</div>
<p><span id="a_AsymmetricObjectProperty"> </span>
  相反地，属性可以也可以是<i>不对称的</i>，也就是说，当 A 与 B 连接后，不可以用同一个属性将 B 和 A 连接。
  很明显（排除时间旅行带来的悖论），属性 hasChild 是不对称的，可以这样表示：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> AsymmetricObjectProperty(&nbsp;:hasChild ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:AsymmetricProperty rdf:about="hasChild"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasChild  rdf:type  owl:AsymmetricProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasChild
   Characteristics: Asymmetric
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;AsymmetricObjectProperty&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
 &lt;/AsymmetricObjectProperty&gt;
</pre>
</div>
<p>
  注意，不对称性比非对称更加严格。同样的，对称性比非不对称更加严格。
</p><p><span id="a_DisjointObjectProperties"> </span>
  先前我们将子属性比作子类。
  然而我们也可以把类的不交性带入属性中：如果两个属性不能连接两个相同的个体，
  则这两个属性是不交的。
  根据常见的法律，我们可以这样声明父母和孩子不能结婚：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DisjointObjectProperties(&nbsp;:hasParent&nbsp;:hasSpouse )  
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="hasParent"&gt;
   &lt;owl:propertyDisjointWith rdf:resource="hasSpouse"/&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasParent  owl:propertyDisjointWith &nbsp;:hasSpouse .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> DisjointProperties: hasParent, hasSpouse
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DisjointObjectProperties&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;ObjectProperty IRI="hasSpouse"/&gt;
 &lt;/DisjointObjectProperties&gt;
</pre>
</div>
<p><span id="a_ReflexiveObjectProperty"> </span>
  属性也可以是<i>反身的</i>：这样的属性会将自己与自己联系起来。
  下面这个例子声明自己是自己的亲属：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> ReflexiveObjectProperty(&nbsp;:hasRelative )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:ReflexiveProperty rdf:about="hasRelative"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasRelative  rdf:type  owl:ReflexiveProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasRelative
   Characteristics: Reflexive
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;ReflexiveObjectProperty&gt;
   &lt;ObjectProperty IRI="hasRelative"/&gt;
 &lt;/ReflexiveObjectProperty&gt;
</pre>
</div>
<p>
  注意，这并不意味着由有反身性的属性连接的两个个体是等价的。
</p><p><span id="a_IrreflexiveObjectProperty"> </span>
  属性也可以是<i>非反身的</i>，即个体不能使用这个属性来连接自己。
  比如下面声明人都不是自己的父母：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> IrreflexiveObjectProperty(&nbsp;:parentOf )   
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:IrreflexiveProperty rdf:about="parentOf"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:parentOf  rdf:type  owl:IrreflexiveProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: parentOf
   Characteristics: Irreflexive
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;IrreflexiveObjectProperty&gt;
   &lt;ObjectProperty IRI="parentOf"/&gt;
 &lt;/IrreflexiveObjectProperty&gt;
</pre>
</div>
<p>
  接下来，由于每个人最多只能由一位丈夫（为了举例我们认为这是必须的），
  我们可以定义 hasHusband 属性使其最多连接一个个体。
  <span id="a_FunctionalObjectProperty"> </span>
  这种属性被称为<i>专一的</i>，可以这样描述：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> FunctionalObjectProperty(&nbsp;:hasHusband ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:FunctionalProperty rdf:about="hasHusband"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasHusband  rdf:type  owl:FunctionalProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasHusband
   Characteristics: Functional
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;FunctionalObjectProperty&gt;
   &lt;ObjectProperty IRI="hasHusband"/&gt;
 &lt;/FunctionalObjectProperty&gt;
</pre>
</div>
<p>
  注意，这样的声明并不要求每一个个体都有一位丈夫，这仅仅声明丈夫的数量不能超过一位。
  因此，如果我们声明 Mary 的丈夫是 James 后声明 Mary 的丈夫是 Jim，
  这将表明 Jim 和 James 是同一个体。
</p><p><span id="a_InverseFunctionalObjectProperty"> </span>
  我们也可以声明一个属性的翻转是专一的：
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> InverseFunctionalObjectProperty(&nbsp;:hasHusband ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:InverseFunctionalProperty rdf:about="hasHusband"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasHusband  rdf:type  owl:InverseFunctionalProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasHusband
   Characteristics: InverseFunctional
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;InverseFunctionalObjectProperty&gt;
   &lt;ObjectProperty IRI="hasHusband"/&gt;
 &lt;/InverseFunctionalObjectProperty&gt;
</pre>
</div>
<p>
  这表明一个个体可以最多作为一个其他个体的丈夫。
  这个例子同样展示了专一性和翻转专一性的区别，
  比如在一夫多妻的情况下专一性成立而翻转专一性不成立。
</p><p><span id="a_TransitiveObjectProperty"> </span>
  接下来我们定义属性 hasAncestor （有祖先是...）可以连接两个个体 A 和 B，
  其中 A 是 B 的直接后代。
  显然，属性 hasParent 是 hasAncestor 的特殊情况，我们可以像先前那样定义为子属性。
  但如果 hasAncestor 属性能够自动包括父母的父母（以及父母的父母的父母）将会很方便。
  我们可以通过将 hasAncestor 定义为<i>可传递的</i>来实现这一功能。
  可传递的属性会在 A 与 B 连接，B 与 C 连接时自动连接 A 与 C。
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> TransitiveObjectProperty(&nbsp;:hasAncestor )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:TransitiveProperty rdf:about="hasAncestor"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasAncestor  rdf:type  owl:TransitiveProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasAncestor
   Characteristics: Transitive
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;TransitiveObjectProperty&gt;
   &lt;ObjectProperty IRI="hasAncestor"/&gt;
 &lt;/TransitiveObjectProperty&gt;
</pre>
</div>
<a id="Property_Chains" name="Property_Chains"></a><h3> <span class="mw-headline">6.2 Property Chains</span></h3>
<p><span id="a_SubObjectPropertyOfChain"> </span>
While the last example from the previous section implied the presence of
 an hasAncestor property whenever there is a chain of hasParent 
properties, we might want to be a bit more specific and define, say, a 
hasGrandparent property instead. Technically, this means that we want 
hasGrandparent to connect all individuals that are linked by a chain of 
exactly two hasParent properties. In contrast to the previous 
hasAncestor example, we do not want hasParent to be a special case of 
hasGrandparent nor do we want hasGrandparent to refer to 
great-grandparents etc. We can express that every such chain has to be 
spanned by a hasGrandparent property as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasParent&nbsp;:hasParent ) 
  &nbsp;:hasGrandparent 
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="hasGrandparent"&gt;
       &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
               &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
               &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
       &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasGrandparent  owl:propertyChainAxiom  (&nbsp;:hasParent &nbsp;:hasParent ) .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> ObjectProperty: hasGrandparent
   SubPropertyChain: hasParent o hasParent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasGrandparent"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="Keys" name="Keys"></a><h3> <span class="mw-headline">6.3  Keys </span></h3>
<p><span id="a_HasKey"> </span>
In OWL 2 a collection of (data or object) properties can be assigned as a
 key to a class expression. This means that each named instance of the 
class expression is uniquely identified by the set of values which these
 properties attain in relation to the instance. 
</p><p>A simple example of this would be the identification of a person by her social security number.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> HasKey(&nbsp;:Person () (&nbsp;:hasSSN ) )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;owl:hasKey rdf:parseType="Collection"&gt;
     &lt;owl:DataProperty rdf:about="hasSSN"/&gt;
   &lt;/owl:hasKey&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Person owl:hasKey (&nbsp;:hasSSN ) .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Person
   HasKey: hasSSN
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;HasKey&gt;
   &lt;Class IRI="Person"/&gt;
   &lt;DataProperty IRI="hasSSN"/&gt;
 &lt;/HasKey&gt;
</pre>
</div>
<a id="Advanced_Use_of_Datatypes" name="Advanced_Use_of_Datatypes"></a><h2> <span class="mw-headline">7 Advanced Use of Datatypes</span></h2>
<p>In Section 4.8, we learned that individuals can be endowed with 
numerical information, essentially by connecting them to a data value 
via a datatype property – just like object properties link to other 
domain individuals. In fact, these parallels extend to the more advanced
 features of datatype usage. 
</p><p>First of all, data values are grouped into datatypes and we have 
seen in Section 4.8 how a range restriction on a datatype property can 
be used to indicate the kind of values this property can link to. 
Moreover, it is possible to express and define new datatypes by 
constraining or combining existing ones. 
<span id="a_DatatypeRestriction"> </span>
Datatypes can be restricted via so-called <i>facets</i>, borrowed from XML Schema Datatypes [<cite><a href="#ref-xml-schema-datatypes" title="">XML Schema Datatypes</a></cite>].
 In the following example, we define a new datatype for a person's age 
by constraining the datatype integer to values between (inclusively) 0 
and 150. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:personAge
   DatatypeRestriction( xsd:integer           
     xsd:minInclusive "0"^^xsd:integer
     xsd:maxInclusive "150"^^xsd:integer
   )
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="personAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:onDatatype rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/&gt;
       &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
         &lt;rdf:Description&gt;
           &lt;xsd:minInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;0&lt;/xsd:minInclusive&gt;
         &lt;/rdf:Description&gt;
         &lt;rdf:Description&gt;
           &lt;xsd:maxInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;150&lt;/xsd:maxInclusive&gt; 
         &lt;/rdf:Description&gt;         
       &lt;/owl:withRestrictions&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:personAge  owl:equivalentClass
  [ rdf:type  rdfs:Datatype;
    owl:onDatatype  xsd:integer;
    owl:withRestrictions (
       [ xsd:minInclusive  "0"^^xsd:integer ]
       [ xsd:maxInclusive  "150"^^xsd:integer ] 
    )
  ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Datatype: personAge
   EquivalentTo: integer[&lt;= 0 , &gt;= 150]
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="personAge"/&gt;
    &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#integer"/&gt;
       &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#minInclusive"&gt;
         &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#maxInclusive"&gt;
         &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;150&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
    &lt;/DatatypeRestriction&gt;
  &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p><span id="a_DataComplementOf"> </span>
<span id="a_DataIntersectionOf"> </span>
<span id="a_DataUnionOf"> </span>
Likewise, datatypes can be combined just like classes by complement, 
intersection and union. Thereby, assuming we have already defined a 
datatype minorAge, we can define the datatype majorAge by excluding all 
data values of minorAge from personAge:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:majorAge
   DataIntersectionOf(
    &nbsp;:personAge 
     DataComplementOf(&nbsp;:minorAge ) 
   ) 
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="majorAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="personAge"/&gt;
         &lt;rdfs:Datatype&gt;
           &lt;owl:datatypeComplementOf rdf:resource="minorAge"/&gt; 
         &lt;/rdfs:Datatype&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt; 
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:majorAge  owl:equivalentClass
   [ rdf:type  rdfs:Datatype;
     owl:intersectionOf (
       &nbsp;:personAge
        [ rdf:type  rdfs:Datatype;
          owl:datatypeComplementOf &nbsp;:minorAge ] 
     )
   ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Datatype: majorAge
    EquivalentTo: personAge and not minorAge
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="majorAge"/&gt;
    &lt;DataIntersectionOf&gt;
       &lt;Datatype IRI="personAge"/&gt;
       &lt;DataComplementOf&gt;
         &lt;Datatype IRI="minorAge"/&gt;
       &lt;/DataComplementOf&gt;
    &lt;/DataIntersectionOf&gt;
  &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p><span id="a_DataOneOf"> </span>
Moreover, a new datatype can be generated by just enumerating the data values it contains. 
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> DatatypeDefinition(
  &nbsp;:toddlerAge
   DataOneOf( "1"^^xsd:integer "2"^^xsd:integer ) 
 ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="toddlerAge"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;rdfs:Datatype&gt;
       &lt;owl:oneOf&gt;
         &lt;rdf:Description&gt;
           &lt;rdf:first rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;1&lt;/rdf:first&gt;
           &lt;rdf:rest&gt;
             &lt;rdf:Description&gt;
               &lt;rdf:first rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;2&lt;/rdf:first&gt;
               &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt;
             &lt;/rdf:Description&gt;
           &lt;/rdf:rest&gt;
         &lt;/rdf:Description&gt;
       &lt;/owl:oneOf&gt;
     &lt;/rdfs:Datatype&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:toddlerAge  owl:equivalentClass
   [ rdf:type rdfs:Datatype;
     owl:oneOf (  "1"^^xsd:integer  "2"^^xsd:integer )
   ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Datatype: toddlerAge
    EquivalentTo: { 1, 2 }
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;DatatypeDefinition&gt;
    &lt;Datatype IRI="toddlerAge"/&gt;
    &lt;DataOneOf&gt;
      &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;1&lt;/Literal&gt; 
      &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;2&lt;/Literal&gt;
    &lt;/DataOneOf&gt;
 &lt;/DatatypeDefinition&gt;
</pre>
</div>
<p>In Section 6.1, we saw ways of characterizing object properties. Some
 of those are also available for datatype properties. For example, we 
can express that every person has only one age by characterizing the 
hasAge datatype property as functional:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> FunctionalDataProperty(&nbsp;:hasAge ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:FunctionalProperty rdf:about="hasAge"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:hasAge  rdf:type  owl:FunctionalProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> DataProperty: hasAge
   Characteristics: Functional
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre>&lt;FunctionalDataProperty&gt;
  &lt;DataProperty IRI="hasAge"/&gt;
&lt;/FunctionalDataProperty&gt;
</pre>
</div>
<p>New classes can be defined by restrictions on datatype properties. 
The following example defines the class teenager as all individuals 
whose age is between 13 and 19 years.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf(
  &nbsp;:Teenager
   DataSomeValuesFrom(&nbsp;:hasAge
     DatatypeRestriction( xsd:integer
       xsd:minExclusive "12"^^xsd:integer
       xsd:maxInclusive "19"^^xsd:integer
     )
   )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre>&lt;owl:Class rdf:about="Teenager"&gt;
  &lt;rdfs:subClassOf&gt;
    &lt;owl:Restriction&gt;
      &lt;owl:onProperty rdf:resource="hasAge"/&gt;
      &lt;owl:someValuesFrom&gt;
        &lt;rdfs:Datatype&gt;
          &lt;owl:onDatatype rdf:resource="http://www.w3.org/2001/XMLSchema#integer"/&gt;
          &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
            &lt;rdf:Description&gt;
              &lt;xsd:minExclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;12&lt;/xsd:minExclusive&gt;
            &lt;/rdf:Description&gt;
            &lt;rdf:Description&gt;
              &lt;xsd:maxInclusive rdf:datatype="http://www.w3.org/2001/XMLSchema#integer"&gt;19&lt;/xsd:maxInclusive&gt;
            &lt;/rdf:Description&gt;
          &lt;/owl:withRestrictions&gt;
        &lt;/rdfs:Datatype&gt;
      &lt;/owl:someValuesFrom&gt;
    &lt;/owl:Restriction&gt;
  &lt;/rdfs:subClassOf&gt;
&lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>:Teenager  rdfs:subClassOf
       [ rdf:type             owl:Restriction&nbsp;;
         owl:onProperty      &nbsp;:hasAge&nbsp;;
         owl:someValuesFrom   
          [ rdf:type             rdfs:Datatype&nbsp;;
            owl:onDatatype       xsd:integer&nbsp;;
            owl:withRestrictions (  [ xsd:minExclusive     "12"^^xsd:integer ]
                                    [ xsd:maxInclusive     "19"^^xsd:integer ]
            )
          ]
       ] .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre>Class: Teenager
  SubClassOf: hasAge some integer[&lt; 12 , &gt;= 19]
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre>&lt;SubClassOf&gt;
  &lt;Class IRI="Teenager"/&gt;
  &lt;DataSomeValuesFrom&gt;
    &lt;DataProperty IRI="hasAge"/&gt;
    &lt;DatatypeRestriction&gt;
      &lt;Datatype IRI="http://www.w3.org/2001/XMLSchema#integer"/&gt;
      &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#minExclusive"&gt;
        &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;12&lt;/Literal&gt;
      &lt;/FacetRestriction&gt;
      &lt;FacetRestriction facet="http://www.w3.org/2001/XMLSchema#maxInclusive"&gt;
        &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#integer"&gt;19&lt;/Literal&gt;
      &lt;/FacetRestriction&gt;
    &lt;/DatatypeRestriction&gt;
  &lt;/DataSomeValuesFrom&gt;
&lt;/SubClassOf&gt;
</pre>
</div>
<a id="Document_Information_and_Annotations" name="Document_Information_and_Annotations"></a><h2> <span class="mw-headline">8 Document Information and Annotations</span></h2>
<p>In the following, we describe features of OWL 2 which do not actually
 contribute to the “logical” knowledge specified in the ontology. Rather
 these are used to provide additional information about the ontology 
itself, axioms, or even single entities.
</p>
<a id="Annotating_Axioms_and_Entities" name="Annotating_Axioms_and_Entities"></a><h3> <span class="mw-headline">8.1 Annotating Axioms and Entities</span></h3>
<p><span id="a_Annotation"> </span>
In many cases, we want to furnish parts of our OWL ontology with 
information that actually does not describe the domain itself but talks 
about the description of the domain.  OWL provides <span id="Aannotation">annotations</span>
 for this purpose.  An OWL annotation simply associates property-value 
pairs with parts of an ontology, or the entire ontology itself.  Even 
annotations themselves can be annotated. Annotation information is not 
really part of the logical meaning of an ontology.
</p><p><span id="a_AnnotationAssertion"> </span>
So, for example, we could add information to one of the classes of our 
ontology, giving a natural language description of its meaning.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> AnnotationAssertion( rdfs:comment&nbsp;:Person "Represents the set of all people." )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Person"&gt;
   &lt;rdfs:comment&gt;Represents the set of all people.&lt;/rdfs:comment&gt;
 &lt;/owl:Class&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Person  rdfs:comment  "Represents the set of all people."^^xsd:string .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Person
   Annotations: rdfs:comment "Represents the set of all people."
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;AnnotationAssertion&gt;
   &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
   &lt;IRI&gt;Person&lt;/IRI&gt;                       
   &lt;Literal&gt;Represents the set of all people.&lt;/Literal&gt;
 &lt;/AnnotationAssertion&gt;
</pre>
</div>
<p>The following is an example of an axiom with an annotation.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf( 
   Annotation( rdfs:comment "States that every man is a person." )
  &nbsp;:Man 
  &nbsp;:Person 
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Man"&gt;
   &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
 &lt;/owl:Class&gt;
 &lt;owl:Axiom&gt;
   &lt;owl:annotatedSource rdf:resource="Man"/&gt;
   &lt;owl:annotatedProperty rdf:resource="&amp;rdfs;subClassOf"/&gt;
   &lt;owl:annotatedTarget rdf:resource="Person"/&gt;
   &lt;rdfs:comment&gt;States that every man is a person.&lt;/rdfs:comment&gt;
 &lt;/owl:Axiom&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Man rdfs:subClassOf&nbsp;:Person .
 []  rdf:type       owl:Axiom&nbsp;;
     owl:annotatedSource   &nbsp;:Man&nbsp;;
     owl:annotatedProperty  rdfs:subClassOf&nbsp;;
     owl:annotatedTarget   &nbsp;:Person&nbsp;;
     rdfs:comment     "States that every man is a person."^^xsd:string .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Man
   SubClassOf: Annotations: rdfs:comment "States that every man is a person." Person
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Annotation&gt;
       &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
       &lt;Literal datatypeIRI="http://www.w3.org/2001/XMLSchema#string"&gt;"States that every man is a person."&lt;/Literal&gt;
   &lt;/Annotation&gt;
   &lt;Class IRI="Man"/&gt;
   &lt;Class IRI="Person"/&gt;
 &lt;/SubClassOf&gt;
</pre>
</div>
<p>Often such annotations are used in tools to provide access to natural language text to be displayed in help interfaces.
</p>
<a id="Ontology_Management" name="Ontology_Management"></a><h3> <span class="mw-headline">8.2 Ontology Management</span></h3>
<p>In OWL, general information about a topic is almost always gathered into an <span id="Aontology">ontology</span> that is then used by various applications.  We can also provide a <span id="Aontologyname">name for OWL ontologies</span>,
 which is generally the place where the ontology document is located in 
the web. Particular information about a topic can also be placed in an 
ontology, if it is used by different applications.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> Ontology(&lt;http://example.com/owl/families&gt;
   ...
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:RDF ...&gt;
   &lt;owl:Ontology rdf:about="http://example.com/owl/families"/&gt;
   ...
 &lt;/rdf:RDF&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> &lt;http://example.com/owl/families&gt; rdf:type owl:Ontology .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Ontology: &lt;http://example.com/owl/families&gt;
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;Ontology ...
   ontologyIRI="http://example.com/owl/families"&gt;
   ...
 &lt;/Ontology&gt;
</pre>
</div>
<p>
  我们将 OWL 本体写入 OWL 文档中，并将其放在本地文件系统中或者万维网上。
  除了包含 OWL 本体，OWL 文档也包含在 OWL 本体中使用的缩略名称（比如“人”）转换为 IRI 的相关信息。
  We place OWL ontologies into OWL documents, which are then placed 
into local filesystems or on the World Wide Web.  Aside from containing 
an OWL ontology, OWL documents also contain information about 
transforming the short names normally used in OWL ontologies (e.g., 
Person) into IRIs, 
by <span id="Anamespace">providing the expansion for prefixes</span>. 
The IRI is then the concatenation of the prefix expansion and the reference.
</p><p>In our example we have so far used a number of prefixes, including <span class="name">xsd</span>
 and the empty prefix. The former prefix has been used in compact names 
for XML Schema datatypes, whose IRIs are fixed by the XML Schema 
recommendation. We thus must use the standard expansion for <span class="name">xsd</span>, 
which is <span class="name">http://www.w3.org/2001/XMLSchema#</span>.
 The expansion we pick for the other prefix will affect the names of the
 classes, properties, and individuals in our ontology, as well as the 
name of the ontology itself. If we are going to put the ontology on the 
web, we should pick an expansion that is in some part of the web that we
 control, so that we are not using someone else's names by accident. 
(Here we use a made-up place that no one controls.) The two XML-based 
syntaxes need namespaces for built-in names and also can use XML entity 
references for namespaces. In general, it should be noted that the 
available abbreviation mechanisms and their specific syntax is different
 in each of the serializations of OWL, even in cases where similar 
keywords are used.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> Prefix(:=&lt;http://example.com/owl/families/&gt;)
 Prefix(otherOnt:=&lt;http://example.org/otherOntologies/families/&gt;)
 Prefix(xsd:=&lt;http://www.w3.org/2001/XMLSchema#&gt;)
 Prefix(owl:=&lt;http://www.w3.org/2002/07/owl#&gt;)
 
 Ontology(&lt;http://example.com/owl/families&gt;
    ...
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;!DOCTYPE rdf:RDF [
     &lt;!ENTITY owl "http://www.w3.org/2002/07/owl#" &gt;
     &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
     &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
     &lt;!ENTITY otherOnt "http://example.org/otherOntologies/families/" &gt;
 ]&gt;
 
 &lt;rdf:RDF xml:base="http://example.com/owl/families/"
     xmlns="http://example.com/owl/families/"
     xmlns:otherOnt="http://example.org/otherOntologies/families/"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:xml="http://www.w3.org/2001/XMLSchema#"&gt;
 
     &lt;owl:Ontology rdf:about="http://example.com/owl/families"/&gt;
 ...
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> @prefix&nbsp;: &lt;http://example.com/owl/families/&gt; .
 @prefix otherOnt: &lt;http://example.org/otherOntologies/families/&gt; .
 @prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
 @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
 @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
 @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Prefix:&nbsp;: &lt;http://example.com/owl/families/&gt;
 Prefix: xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
 Prefix: owl: &lt;http://www.w3.org/2002/07/owl#&gt;
 Prefix: otherOnt: &lt;http://example.org/otherOntologies/families/&gt;
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;!DOCTYPE Ontology [
    &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
 ]&gt;
 &lt;Ontology
   xml:base="http://example.com/owl/families/"
   ontologyIRI="http://example.com/owl/families"
   xmlns="http://www.w3.org/2002/07/owl#"&gt;
   &lt;Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/&gt;
 
  ...
 &lt;/Ontology&gt;
</pre>
</div>
<p><span id="a_imports"> </span>
It is also common in OWL to reuse general information that is stored in 
one ontology in other ontologies. Instead of requiring the copying of 
this information, OWL allows the import of the contents of entire 
ontologies in other ontologies, using import statements, as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> Import( &lt;http://example.org/otherOntologies/families.owl&gt; )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Ontology rdf:about="http://example.com/owl/families"&gt;
   &lt;owl:imports rdf:resource="http://example.org/otherOntologies/families.owl" /&gt;
 &lt;/owl:Ontology&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> &lt;http://example.com/owl/families&gt; owl:imports &lt;http://example.org/otherOntologies/families.owl&gt; .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Import: &lt;http://example.org/otherOntologies/families.owl&gt;
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;Prefix name="otherOnt" IRI="http://example.org/otherOntologies/families/"/&gt;
 &lt;Import&gt;http://example.org/otherOntologies/families.owl&lt;/Import&gt;
</pre>
</div>
<p><br>
As the Semantic Web and ontology construction is distributed, it is 
common for ontologies to use different names for the same concept, 
property, or individual. As we have seen, several constructs in OWL can 
be used to state that different names refer to the same <span id="Aclassequivalentnway">class</span>, <span id="Adatapropertyequivalentnway"><span id="Aobjectpropertyequivalentnway">property</span></span>, or <span id="Aindividualsamenway">individual</span>,
 so, for example, we could – instead of tediously renaming entities – 
tie the names used in our ontology to the names used in an imported 
ontology as follows:
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SameIndividual(&nbsp;:John otherOnt:JohnBrown )
 SameIndividual(&nbsp;:Mary otherOnt:MaryBrown )
 EquivalentClasses(&nbsp;:Adult otherOnt:Grownup )
 EquivalentObjectProperties(&nbsp;:hasChild otherOnt:child )
 EquivalentDataProperties(&nbsp;:hasAge otherOnt:age )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;rdf:Description rdf:about="John"&gt;
   &lt;owl:sameAs rdf:resource="&amp;otherOnt;JohnBrown"/&gt;
 &lt;/rdf:Description&gt;

 &lt;rdf:Description rdf:about="Mary"&gt;
   &lt;owl:sameAs rdf:resource="&amp;otherOnt;MaryBrown"/&gt;
 &lt;/rdf:Description&gt;

 &lt;owl:Class rdf:about="Adult"&gt;
   &lt;owl:equivalentClass rdf:resource="&amp;otherOnt;Grownup"/&gt;
 &lt;/owl:Class&gt;

 &lt;owl:ObjectProperty rdf:about="hasChild"&gt;
   &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;child"/&gt;
 &lt;/owl:ObjectProperty&gt;

 &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
   &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;age"/&gt;
 &lt;/owl:DatatypeProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Mary      owl:sameAs              otherOnt:MaryBrown .
&nbsp;:John      owl:sameAs              otherOnt:JohnBrown .
&nbsp;:Adult     owl:equivalentClass     otherOnt:Grownup .
&nbsp;:hasChild  owl:equivalentProperty  otherOnt:child .
&nbsp;:hasAge    owl:equivalentProperty  otherOnt:age .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> SameIndividual: John, otherOnt:JohnBrown 
 SameIndividual: Mary, otherOnt:MaryBrown
 EquivalentClasses: Adult, otherOnt:Grownup
 EquivalentProperties: hasChild, otherOnt:child
 EquivalentProperties: hasAge,   otherOnt:age
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="John"/&gt;
   &lt;NamedIndividual abbreviatedIRI="otherOnt:JohnBrown"/&gt;
 &lt;/SameIndividual&gt;

 &lt;SameIndividual&gt;
   &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;NamedIndividual abbreviatedIRI="otherOnt:MaryBrown"/&gt;
 &lt;/SameIndividual&gt;

 &lt;EquivalentClasses&gt;
   &lt;Class IRI="Adult"/&gt;
   &lt;Class abbreviatedIRI="otherOnt:Grownup"/&gt;
 &lt;/EquivalentClasses&gt;

 &lt;EquivalentObjectProperties&gt;
   &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;ObjectProperty abbreviatedIRI="otherOnt:child"/&gt;
 &lt;/EquivalentObjectProperties&gt;

 &lt;EquivalentDataProperties&gt;
   &lt;DataProperty IRI="hasAge"/&gt;
   &lt;DataProperty abbreviatedIRI="otherOnt:age"/&gt;
 &lt;/EquivalentDataProperties&gt;
</pre>
</div>
<a id="Entity_Declarations" name="Entity_Declarations"></a><h3> <span class="mw-headline">8.3 Entity Declarations</span></h3>
<p><span id="a_DeclarationClass"> </span><span id="a_DeclarationObjectProperty"> </span><span id="a_DeclarationDataProperty"> </span><span id="a_NamedIndividual"> </span>
</p><p>To help with managing ontologies, OWL has the notion of 
declarations. The basic idea is that each class, property, or individual
 is supposed to be declared in an ontology, and then it can be used in 
that ontology and ontologies that import that ontology.
</p><p>In the 曼彻斯特语法, declarations are implicit. Constructs 
that provide information about a class, property, or individual 
implicitly declare that class, property, or individual if needed.  The 
other syntaxes have explicit declarations.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> Declaration( NamedIndividual(&nbsp;:John ) )
 Declaration( Class(&nbsp;:Person ) )
 Declaration( ObjectProperty(&nbsp;:hasWife ) )
 Declaration( DataProperty(&nbsp;:hasAge ) )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:NamedIndividual rdf:about="John"/&gt;
 &lt;owl:Class rdf:about="Person"/&gt;
 &lt;owl:ObjectProperty rdf:about="hasWife"/&gt;
 &lt;owl:DatatypeProperty rdf:about="hasAge"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:John    rdf:type owl:NamedIndividual .
&nbsp;:Person  rdf:type owl:Class .
&nbsp;:hasWife rdf:type owl:ObjectProperty .
&nbsp;:hasAge  rdf:type owl:DatatypeProperty .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Individual: John
 Class: Person
 ObjectProperty: hasWife
 DataProperty: hasAge
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;Declaration&gt;
     &lt;NamedIndividual IRI="John"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;Class IRI="Person"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
 &lt;/Declaration&gt;
 &lt;Declaration&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
 &lt;/Declaration&gt;
</pre>
</div>
<p>However, an IRI may denote different entity-types (e.g. both an 
individual and a class) at the same time. This possibility, called 
“punning,” has been introduced to allow for a certain amount of 
metamodeling; we give an example of this in <a href="#OWL_2_DL_and_OWL_2_Full" title="">Section 9</a>.
 Still, OWL 2 does require some discipline in using and reusing names.  
To allow a more readable syntax, and for other technical reasons, OWL 2 
DL requires that a name is not used for more than one property type 
(object, datatype or annotation property) nor can an IRI denote both a 
class and a datatype.  Moreover, “built-in” names (such as those used by
 RDF and RDFS and various syntaxes of OWL) cannot be freely used in OWL.
</p>
<a id="OWL_2_DL_and_OWL_2_Full" name="OWL_2_DL_and_OWL_2_Full"></a><h2> <span class="mw-headline">9 OWL 2 DL and OWL 2 Full</span></h2>
<p>There are two alternative ways of assigning meaning to ontologies in OWL 2 called the Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] and the RDF-Based Semantics [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>].
 The Direct Semantics can be applied to ontologies that are in the OWL 2
 DL subset of OWL 2, which is defined in OWL 2 函数式语法 
document [<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>]. Ontologies that are not in OWL 2 DL are often said to belong to <i>OWL 2 Full</i>, and can only be interpreted under RDF-Based Semantics. Informally, the term <i>OWL 2 DL</i>
 is often used to refer to OWL 2 ontologies interpreted using the Direct
 Semantics, but it is also possible to interpret OWL 2 DL ontologies 
under RDF-Based Semantics.
</p><p>The Direct Semantics [<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] provides a meaning for OWL 2 in a Description Logic [<cite><a href="#ref-description-logics" title="">Description Logics</a></cite>] style.  
  The RDF-Based Semantics [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>] is an extension of the semantics for RDFS [<cite><a href="#ref-rdf-semantics" title="">RDF Semantics</a></cite>] and is based on viewing OWL 2 ontologies as RDF graphs.
</p><p>When thinking about ontologies the differences between these two 
semantics are generally quite slight. Indeed, given an OWL 2 DL 
ontology, many inferences drawn using the Direct Semantics remain valid 
inferences under the RDF-Based Semantics – see the correspondence 
theorem in <a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/#Correspondence_Theorem" title="RDF-Based Semantics">Section 7.2</a> of the RDF-Based Semantics document [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>].
 The two main differences are that under the Direct Semantics 
annotations have no formal meaning and under the RDF-Based Semantics 
there are some extra inferences that arise from the RDF view of the 
universe.
</p><p>Conceptually, we can think of the difference between OWL 2 DL 
(under Direct Semantics) and OWL 2 Full (under RDF-Based Semantics) in 
two ways:
</p>
<ul><li> One can see OWL 2 DL as a syntactically restricted version of 
OWL 2 Full where the restrictions are designed to make life easier for 
implementors. In fact, since OWL 2 Full (under the RDF-Based Semantics) 
is undecidable, OWL 2 DL (under the Direct Semantics) makes writing a 
reasoner that, in principle, can return all "yes or no" answers (subject
 to resource constraints) possible. As a consequence of its design, 
there are several production quality reasoners that cover the entire OWL
 2 DL language under the Direct Semantics. There are no such reasoners 
for OWL 2 Full under the RDF-Based Semantics.
</li></ul>
<ul><li> One can see OWL 2 Full as the most straightforward extension of
 RDFS. As such, the RDF-Based Semantics for OWL 2 Full follows the RDFS 
semantics and general syntactic philosophy (i.e., everything is a triple
 and the language is fully reflective).
</li></ul>
<p>Of course, the two semantics have been designed together and thus 
have influenced each other. For example, one design goal of OWL 2 was to
 bring OWL 2 DL syntactically closer to OWL 2 Full (that is, to allow 
more RDF Graphs/OWL 2 Full ontologies to be legal OWL 2 DL ontologies). 
This led to the incorporation of so-called <span id="a_Punning"> </span><i>punning</i>
 into OWL 2, e.g., using the same IRI as a name for both a class and an 
individual. An example of such usage would be the following, which 
states that John is a father, and that father is a social role.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre>ClassAssertion(&nbsp;:Father&nbsp;:John ) 
ClassAssertion(&nbsp;:SocialRole&nbsp;:Father ) 
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre>&lt;Father rdf:about="John"/&gt;
&lt;SocialRole rdf:about="Father"/&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>:John rdf:type&nbsp;:Father .
:Father rdf:type&nbsp;:SocialRole .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre>Individual: John   
  Types: Father
Individual: Father 
  Types: SocialRole
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre>&lt;ClassAssertion&gt;
    &lt;Class IRI="Father"/&gt;
    &lt;NamedIndividual IRI="John"/&gt;
&lt;/ClassAssertion&gt;
&lt;ClassAssertion&gt;
    &lt;Class IRI="SocialRole"/&gt;
    &lt;NamedIndividual IRI="Father"/&gt;
&lt;/ClassAssertion&gt;
</pre>
</div>
<p>Note that in the first statement, Father is used as a class, while in
 the second it is used as an individual. In this sense, SocialRole acts 
as a metaclass for the class Father.
</p><p>In OWL 1, a document containing these two statements would be an 
OWL 1 Full document, but not an OWL 1 DL document. In OWL 2 DL, however,
 this is allowed. It must be noted, though, that the Direct Semantics of
 OWL 2 DL accommodates this by understanding the class Father and the 
individual Father as two different views on the same IRI, i.e. they are 
interpreted semantically as if they were distinct. In particular, if two
 individuals are equal, then the classes that they denote are equivalent
 under RDF-Based Semantics, whereas there is no such relationship 
between the classes under Direct Semantics. This is possibly the one 
difference between the two semantics that is most relevant in practice.
</p>
<a id="OWL_2_Profiles" name="OWL_2_Profiles"></a><h2> <span class="mw-headline">10 OWL 2 Profiles</span></h2>
<p>In addition to OWL 2 DL and OWL 2 Full, OWL 2 specifies three 
profiles. OWL 2, in general, is a very expressive language (both 
computationally and for users) and thus can be difficult to implement 
well and to work with. These additional profiles are designed to be 
approachable subsets of OWL 2 sufficient for a variety of applications. 
As with OWL 2 DL, computational considerations are a major requirement 
of these profiles (and they are all much easier to implement with robust
 scalability given existing technology), but there are many subsets of 
OWL 2 that have good computational properties. The selected OWL 2 
profiles were identified as having substantial user communities already,
 although there were several others not included and one should expect 
more to emerge. The [<cite><a href="#ref-owl-2-profiles" title="">OWL 2 Profiles</a></cite>] document provides a clear template for specifying additional profiles.
</p><p>In order to guarantee scalable reasoning, the existing profiles 
share some limitations regarding their expressiveness. In general, they 
disallow negation and disjunction, as these constructs complicate 
reasoning and have proved to be only rarely needed for modeling. For 
example, in none of the profiles it is possible to specify that every 
person is either male or female.
Further specific modeling restrictions of the profiles will be dealt 
with in the sections on the individual profiles.
</p><p>We discuss each profile and its design rationale, and provide 
some guidance for users in selecting which profile to work with. Please 
be aware that this discussion is not comprehensive, nor can it be. Part 
of any decision has to be based on available tooling and how that fits 
in with the rest of your system or workflow. A more extended discussion 
and comparison of the profiles can be found in the literature [<cite><a href="#ref-owlprofilesintro" title="">OWL 2 Profiles Introduction</a></cite>].
</p><p>By and large, different profiles can be distinguished 
syntactically, and some of the profiles contain others. For example, OWL
 2 DL can be seen as a syntactic fragment of OWL 2 Full and OWL 2 QL is a
 syntactic fragment of OWL 2 DL (and thus of OWL 2 Full). None of these 
profiles below is a subset of another. Ideally, one can use a reasoner 
(or other tool) that is conforming for a superprofile on the subprofile 
with no change in the results derived. In particular, every conforming 
OWL 2 DL reasoner is also a conforming reasoner for OWL 2 EL, OWL 2 RL, 
and OWL 2 QL (but may differ in performance since the OWL 2 DL reasoner 
is tuned for a more general set of cases). Each of the two semantics of 
OWL 2 (see <a href="#OWL_2_DL_and_OWL_2_Full" title="">Section 9</a>) 
can be used for any of the profiles, but it is most common to use Direct
 Semantics for OWL 2 EL and OWL 2 QL, and RDF-Based Semantics for OWL 2 
RL.
</p>
<a id="OWL_2_EL" name="OWL_2_EL"></a><h3> <span class="mw-headline">10.1 OWL 2 EL</span></h3>
<p>Working with OWL 2 EL is fairly similar to working with OWL 2 DL: one
 can use class expressions on both sides of a subClassOf statement and 
even infer such relations. For many large, class-expression oriented 
ontologies, by only a little simplification one can get an OWL 2 EL 
ontology and preserve the bulk of the meaning of the original ontology.
</p><p>OWL 2 EL is designed with large biohealth ontologies in mind, 
such as SNOMED-CT, the NCI thesaurus, and Galen. Common characteristics 
of such ontologies include complex structural descriptions (e.g., 
defining certain body parts in terms of what parts they contain and are 
contained in or propagating diseases along part-subpart relations), huge
 numbers of classes, the heavy use of classification to manage the 
terminology, and the application of the resulting terminology to vast 
amounts of data. Thus, OWL 2 EL has a comparatively expressive class 
expression language and it has no restrictions on how they may be used 
in axioms. It also has fairly expressive property expressions, including
 property chains but excluding inverse.
</p><p>Sensible use of OWL 2 EL is obviously not restricted to the 
biohealth domain: as with the other profiles, OWL 2 EL is domain 
independent. However, OWL 2 EL shines when your domain and your 
application require recognition of structurally complex objects. Such 
domains include system configurations, product inventories, and many 
scientific domains.
</p><p>Besides negation and disjunction, OWL 2 EL also disallows 
universal quantification on properties. Therefore propositions like “all
 children of a rich person are rich” cannot be stated. Moreover, as all 
kinds of role inverses are not available, there is no way of specifying 
that, say, parentOf and childOf are inverses of each other.
</p><p>The EL acronym reflects the profile's basis in the so-called EL family of description logics [<cite><a href="#ref-ELpp" title="">EL++</a></cite>]; they are Languages providing mainly Existential quantification of variables.
</p><p>The following is an example which uses some of the typical modeling features available in OWL 2 EL.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf(
  &nbsp;:Father 
   ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
 )
 
 EquivalentClasses(
  &nbsp;:Parent 
   ObjectSomeValuesFrom(
    &nbsp;:hasChild 
    &nbsp;:Person
   )
 )
 
 EquivalentClasses( 
  &nbsp;:NarcisticPerson 
   ObjectHasSelf(&nbsp;:loves ) 
 )
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father 
  &nbsp;:YoungChild 
 )
 
 SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother ) 
  &nbsp;:hasUncle 
 )
 
 NegativeObjectPropertyAssertion( 
  &nbsp;:hasDaughter 
  &nbsp;:Bill 
  &nbsp;:Susan 
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="Father"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Man"/&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:Class rdf:about="Parent"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:about="hasChild"/&gt;
       &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:Class rdf:about="NarcisticPerson"&gt;
   &lt;owl:equivalentClass&gt;
     &lt;owl:Restriction&gt;
       &lt;owl:onProperty rdf:resource="loves"/&gt;
       &lt;owl:hasSelf rdf:datatype="http://www.w3.org/2001/XMLSchema#boolean"&gt;
         true
       &lt;/owl:hasSelf&gt;
     &lt;/owl:Restriction&gt;
   &lt;/owl:equivalentClass&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;

 &lt;rdf:Description rdf:about="hasUncle"&gt;
   &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
     &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
     &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
   &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
 
 &lt;owl:NegativePropertyAssertion&gt;
   &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
   &lt;owl:assertionProperty rdf:resource="hasDaughter"/&gt;
   &lt;owl:targetIndividual rdf:resource="Susan"/&gt;
 &lt;/owl:NegativePropertyAssertion&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:Father  rdfs:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
 ] .
 
&nbsp;:Parent  owl:equivalentClass  [
   rdf:type            owl:Restriction&nbsp;;
   owl:onProperty     &nbsp;:hasChild&nbsp;;
   owl:someValuesFrom &nbsp;:Person
 ] .
 
&nbsp;:NarcisticPerson  owl:equivalentClass  [
   rdf:type        owl:Restriction&nbsp;;
   owl:onProperty &nbsp;:loves&nbsp;;
   owl:hasSelf     true
 ] .
 
 [] rdf:type     owl:AllDisjointClasses&nbsp;;
    owl:members  (&nbsp;:Mother &nbsp;:Father&nbsp;:YoungChild ) .
 
&nbsp;:hasUncle  owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .
 
 []  rdf:type               owl:NegativePropertyAssertion&nbsp;;
     owl:sourceIndividual  &nbsp;:Bill&nbsp;;
     owl:assertionProperty &nbsp;:hasDaughter&nbsp;;
     owl:targetIndividual  &nbsp;:Susan .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: Father
   SubClassOf: Man and Parent
 
 Class: Parent
   EquivalentTo: hasChild some Person
 
 Class: NarcisticPerson
   EquivalentTo: loves Self
 
 DisjointClasses: Mother, Father, YoungChild
 
 ObjectProperty: hasUncle
   SubPropertyChain: hasFather o hasBrother
 
 Individual: Bill
   Facts: not hasDaughter Susan
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="Father"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;EquivalentClasses&gt;
   &lt;Class IRI="Parent"/&gt;
   &lt;ObjectSomeValuesFrom&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/ObjectSomeValuesFrom&gt;
 &lt;/EquivalentClasses&gt;
 
 &lt;EquivalentClasses&gt;
   &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;ObjectHasSelf&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/ObjectHasSelf&gt;
 &lt;/EquivalentClasses&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasUncle"/&gt;
 &lt;/SubObjectPropertyOf&gt;
 
 &lt;NegativeObjectPropertyAssertion&gt;
   &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;NamedIndividual IRI="Susan"/&gt;
 &lt;/NegativeObjectPropertyAssertion&gt;
</pre>
</div>
<a id="OWL_2_QL" name="OWL_2_QL"></a><h3> <span class="mw-headline">10.2 OWL 2 QL</span></h3>
<p>OWL 2 QL can be realized using standard relational database 
technology (e.g., SQL) simply by expanding queries in the light of class
 axioms. This means it can be tightly integrated with RDBMSs and benefit
 from their robust implementations and multi-user features. Furthermore,
 it can be implemented without having to “touch the data,” so really as a
 translational/preprocessing layer. Expressively, it can represent key 
features of Entity-relationship and UML diagrams (at least those with 
functional restrictions). Thus, it is suitable both for representing 
database schemas and for integrating them via query rewriting. As a 
result, it can also be used directly as a high level database schema 
language, though users may prefer a diagram based syntax.
</p><p>OWL 2 QL also captures many commonly used features in RDFS and 
small extensions thereof, such as inverse properties and subproperty 
hierarchies. OWL 2 QL restricts class axioms asymmetrically, that is, 
you can use constructs as the subclass that you cannot use as the 
superclass.
</p><p>Among other constructs, OWL 2 QL disallows existential 
quantification of roles to a class expression, e.g. it can be stated 
that every person has a parent but not that every person has a female 
parent. Moreover property chain axioms and equality are not supported. 
</p><p>The QL acronym reflects the fact that query answering in this 
profile can be implemented by rewriting queries into a standard 
relational Query Language [<cite><a href="#ref-DL-Lite" title="">DL-Lite</a></cite>].
</p><p>The following is an example which uses some of the typical 
modeling features available in OWL 2 QL. The first axiom states that 
every childless person is a person for which there does not exist 
anybody who has the first person as parent.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf( 
  &nbsp;:ChildlessPerson 
   ObjectIntersectionOf(
    &nbsp;:Person 
     ObjectComplementOf(
       ObjectSomeValuesFrom(
         ObjectInverseOf(&nbsp;:hasParent )
         owl:Thing
       )
     )
   )
 ) 
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father
  &nbsp;:YoungChild 
 )
 
 DisjointObjectProperties( 
  &nbsp;:hasSon 
  &nbsp;:hasDaughter 
 )
 
 SubObjectPropertyOf( 
  &nbsp;:hasFather 
  &nbsp;:hasParent
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class rdf:about="ChildlessPerson"&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Person"/&gt;
         &lt;owl:Class&gt;
           &lt;owl:complementOf&gt;
             &lt;owl:Restriction&gt;
               &lt;owl:onProperty&gt;
                 &lt;owl:ObjectProperty&gt;
                   &lt;owl:inverseOf rdf:resource="hasParent"/&gt;
                 &lt;/owl:ObjectProperty&gt;
               &lt;/owl:onProperty&gt;
               &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
             &lt;/owl:Restriction&gt;
           &lt;/owl:complementOf&gt;
         &lt;/owl:Class&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;
 
 &lt;owl:ObjectProperty rdf:about="hasSon"&gt;
   &lt;owl:propertyDisjointWith rdf:resource="hasDaughter"/&gt;
 &lt;/owl:ObjectProperty&gt;
 
 &lt;owl:ObjectProperty rdf:about="hasFather"&gt;
   &lt;rdfs:subPropertyOf rdf:resource="hasParent"/&gt;
 &lt;/owl:ObjectProperty&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>&nbsp;:ChildlessPerson  owl:subClassOf  [
   rdf:type            owl:Class&nbsp;;
   owl:intersectionOf  (&nbsp;:Person 
                         [ owl:complementOf  [
                             rdf:type            owl:Restriction&nbsp;;
                             owl:onProperty      [ owl:inverseOf &nbsp;:hasParent ]&nbsp;;
                             owl:someValuesFrom  owl:Thing
                           ]
                         ]
                       )
 ] .
 
 []  rdf:type    owl:AllDisjointClasses&nbsp;;
     owl:members (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .
 
&nbsp;:hasSon  owl:propertyDisjointWith &nbsp;:hasDaughter.
 
&nbsp;:hasFather  rdfs:subPropertyOf &nbsp;:hasParent.
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: ChildlessPerson
   SubClassOf: Person and not (inverse hasParent some owl:Thing)
 
 DisjointClasses: Mother, Father, YoungChild
 
 DisjointProperties: hasSon, hasDaughter
 
 ObjectProperty: hasFather
   SubPropertyOf: hasParent
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;ObjectComplementOf&gt;
       &lt;ObjectSomeValuesFrom&gt;
         &lt;ObjectInverseOf&gt;
           &lt;ObjectProperty IRI="hasParent"/&gt;
         &lt;/ObjectInverseOf&gt;
         &lt;Class abbreviatedIRI="owl:Thing"/&gt;
       &lt;/ObjectSomeValuesFrom&gt;
     &lt;/ObjectComplementOf&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;DisjointObjectProperties&gt;
   &lt;ObjectProperty IRI="hasSon"/&gt;
   &lt;ObjectProperty IRI="hasDaughter"/&gt;
 &lt;/DisjointObjectProperties&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectProperty IRI="hasFather"/&gt;
   &lt;ObjectProperty IRI="hasParent"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="OWL_2_RL" name="OWL_2_RL"></a><h3> <span class="mw-headline">10.3 OWL 2 RL</span></h3>
<p>The OWL 2 RL profile is aimed at applications that require scalable 
reasoning without sacrificing too much expressive power. It is designed 
to accommodate both OWL 2 applications that can trade the full 
expressivity of the language for efficiency, and RDF(S) applications 
that need some added expressivity from OWL 2. This is achieved by 
defining a syntactic subset of OWL 2 which is amenable to implementation
 using rule-based technologies, and presenting a partial axiomatization 
of the OWL 2 semantics in the form of first-order implications that can 
be used as the basis for such an implementation. 
</p><p>Suitable rule-based implementations of OWL 2 RL under RDF-Based 
Semantics can be used with arbitrary RDF graphs. As a consequence, OWL 2
 RL is ideal for enriching RDF data, especially when the data must be 
massaged by additional rules. From a modeling perspective, however, this
 pushes us farther away from working with class expressions: OWL 2 RL 
ensures we cannot (easily) talk about unknown individuals in our 
superclass expressions (this restriction follows from the nature of 
rules). Compared with OWL 2 QL, OWL 2 RL works better when you have 
already massaged your data into RDF and are working with it as RDF.
</p><p>Among other constructs, OWL 2 RL disallows statements where the 
existence of an individual enforces the existence of another individual:
 for instance, the statement “every person has a parent” is not 
expressible in OWL RL. 
</p><p>OWL 2 RL restricts class axioms asymmetrically, that is, you can 
use constructs as the subclass that you cannot use as the superclass. 
</p><p>The RL acronym reflects the fact that reasoning in this profile can be implemented using a standard Rule Language [<cite><a href="#ref-dlp" title="">DLP</a></cite>].
</p><p>The following is an example which uses some of the typical 
modeling features available in OWL 2 RL. The first – somewhat contrived –
 axiom states that for each of Mary, Bill, and Meg who is female, the 
following holds: she is a parent with at most one child, and all her 
children (if she has any) are female.
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> SubClassOf(
   ObjectIntersectionOf(
     ObjectOneOf(&nbsp;:Mary&nbsp;:Bill&nbsp;:Meg )
    &nbsp;:Female
   )
   ObjectIntersectionOf(
    &nbsp;:Parent
     ObjectMaxCardinality( 1&nbsp;:hasChild )
     ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:Female )
   )
 )
 
 DisjointClasses( 
  &nbsp;:Mother 
  &nbsp;:Father 
  &nbsp;:YoungChild 
 )
 
 SubObjectPropertyOf( 
   ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother ) 
  &nbsp;:hasUncle 
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre> &lt;owl:Class&gt;
   &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
     &lt;owl:Class&gt;
       &lt;owl:oneOf rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="Mary"/&gt;
         &lt;rdf:Description rdf:about="Bill"/&gt;
         &lt;rdf:Description rdf:about="Meg"/&gt;
       &lt;/owl:oneOf&gt;
     &lt;/owl:Class&gt;
     &lt;owl:Class rdf:about="Female"/&gt;
   &lt;/owl:intersectionOf&gt;
   &lt;rdfs:subClassOf&gt;
     &lt;owl:Class&gt;
       &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
         &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:maxCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#nonNegativeInteger"&gt;
             1
           &lt;/owl:maxCardinality&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;/owl:Restriction&gt;
         &lt;owl:Restriction&gt;
           &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;owl:allValuesFrom rdf:resource="Female"/&gt;
         &lt;/owl:Restriction&gt;
       &lt;/owl:intersectionOf&gt;
     &lt;/owl:Class&gt;
   &lt;/rdfs:subClassOf&gt;
 &lt;/owl:Class&gt;
 
 &lt;owl:AllDisjointClasses&gt;
   &lt;owl:members rdf:parseType="Collection"&gt;
     &lt;owl:Class rdf:about="Mother"/&gt;
     &lt;owl:Class rdf:about="Father"/&gt;
     &lt;owl:Class rdf:about="YoungChild"/&gt;
   &lt;/owl:members&gt;
 &lt;/owl:AllDisjointClasses&gt;

 &lt;rdf:Description rdf:about="hasUncle"&gt;
   &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
     &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
     &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
   &lt;/owl:propertyChainAxiom&gt;
 &lt;/rdf:Description&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre> []  rdf:type            owl:Class&nbsp;;
     owl:intersectionOf  ( [ rdf:type   owl:Class&nbsp;;
                             owl:oneOf  (&nbsp;:Mary &nbsp;:Bill &nbsp;:Meg ) ]
                          &nbsp;:Female 
                         )&nbsp;;
     rdfs:subClassOf     [
       rdf:type            owl:Class&nbsp;;
       owl:intersectionOf  (&nbsp;:Parent  
                             [ rdf:type            owl:Restriction&nbsp;;
                               owl:maxCardinality  "1"^^xsd:nonNegativeInteger&nbsp;;
                               owl:onProperty     &nbsp;:hasChild ]
                             [ rdf:type           owl:Restriction&nbsp;;
                               owl:onProperty    &nbsp;:hasChild&nbsp;;
                               owl:allValuesFrom &nbsp;:Female ]
                           )
     ] .

 []  rdf:type     owl:AllDisjointClasses&nbsp;;
     owl:members  (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .
 
&nbsp;:hasUncle  owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre> Class: X
   SubClassOf: Parent and hasChild max 1 and hasChild only Female
 Class: X
   EquivalentTo: {Mary, Bill, Meg} and Female
 
 DisjointClasses: Mother, Father, YoungChild
 
 ObjectProperty: hasUncle
   SubPropertyChain: hasFather o hasBrother
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre> &lt;SubClassOf&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;ObjectOneOf&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
       &lt;NamedIndividual IRI="Bill"/&gt;
       &lt;NamedIndividual IRI="Meg"/&gt;
     &lt;/ObjectOneOf&gt;
     &lt;Class IRI="Female"/&gt;
   &lt;/ObjectIntersectionOf&gt;
   &lt;ObjectIntersectionOf&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectMaxCardinality cardinality="1"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectMaxCardinality&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Female"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
   &lt;/ObjectIntersectionOf&gt;
 &lt;/SubClassOf&gt;
 
 &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
 &lt;/DisjointClasses&gt;
 
 &lt;SubObjectPropertyOf&gt;
   &lt;ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/ObjectPropertyChain&gt;
   &lt;ObjectProperty IRI="hasUncle"/&gt;
 &lt;/SubObjectPropertyOf&gt;
</pre>
</div>
<a id="OWL_Tools" name="OWL_Tools"></a><h2> <span class="mw-headline">11 OWL Tools</span></h2>
<p>In order to work with OWL ontologies, tool support is essential. 
Basically, there are two types of tools addressing the two main stages 
of the ontology lifecycle: <i>ontology editors</i> are used to create and edit ontologies, whereas <i>reasoners</i>
 are used to query ontologies for implicit knowledge, i.e., they 
determine whether a statement in question is a logical consequence of an
 ontology. 
</p><p>The currently most widely used OWL editor is <a class="external text" href="http://protege.stanford.edu/" rel="nofollow" title="http://protege.stanford.edu/">Protégé</a>,
 a free open-source editing framework developed at Stanford University. 
By virtue of its open plugin structure, it allows for the easy 
integration of special-purpose ontology editing components. Other 
editors include TopQuadrant's commercial <a class="external text" href="http://www.topquadrant.com/products/TB_Composer.html" rel="nofollow" title="http://www.topquadrant.com/products/TB_Composer.html">TopBraid Composer</a> and the open-source systems <a class="external text" href="http://code.google.com/p/swoop/" rel="nofollow" title="http://code.google.com/p/swoop/">SWOOP</a> and <a class="external text" href="http://www.neon-toolkit.org/" rel="nofollow" title="http://www.neon-toolkit.org/">NeOn-Toolkit</a>.
</p><p>There are several reasoners for OWL DL which differ somewhat in 
terms of coverage of the supported reasoning features. For some of 
these, OWL 2 conformance is currently planned and the corresponding 
implementations are in progress. The <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Test_Suite_Status" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Test_Suite_Status">Test Suite Status</a> document lists to which extent some of the reasoners mentioned below comply with the test cases. 
</p><p>For reasoning within OWL DL, the most prominent systems are <a class="external text" href="http://owl.cs.manchester.ac.uk/fact++/" rel="nofollow" title="http://owl.cs.manchester.ac.uk/fact++/">Fact++</a> by the University of Manchester, 
  <a class="external text" href="http://hermit-reasoner.com/" rel="nofollow" title="http://hermit-reasoner.com/">Hermit</a> by Oxford University Computing Laboratory, 
  <a class="external text" href="http://clarkparsia.com/pellet" rel="nofollow" title="http://clarkparsia.com/pellet">Pellet</a> by Clark &amp; Parsia, LLC, and <a class="external text" href="http://www.racer-systems.com/" rel="nofollow" title="http://www.racer-systems.com/">RacerPro</a> by Racer Systems.
</p><p>In addition to those general-purpose reasoners aiming at 
supporting all of OWL DL, there are reasoning systems tailored to the 
tractable profiles of OWL. <a class="external text" href="http://lat.inf.tu-dresden.de/systems/cel/" rel="nofollow" title="http://lat.inf.tu-dresden.de/systems/cel/">CEL</a> by Dresden University of Technology supports OWL EL. 
<a class="external text" href="http://www.dis.uniroma1.it/~quonto/" rel="nofollow" title="http://www.dis.uniroma1.it/~quonto/">QuOnto</a> by Sapienza Università di Roma supports OWL QL. <a class="external text" href="http://www.oracle.com/technology/tech/semantic_technologies/index.html" rel="nofollow" title="http://www.oracle.com/technology/tech/semantic_technologies/index.html">ORACLE 11g</a> supports OWL RL.
</p><p>The open-source <a class="external text" href="http://owlapi.sourceforge.net/" rel="nofollow" title="http://owlapi.sourceforge.net/">OWL API</a> plays a rather prominent role as the currently most important development tool around OWL. 
</p><p>It must be mentioned that by the time this document was created, 
several OWL tools were under development, hence the current overview 
should be seen as a snapshot of this development rather than an 
up-to-date overview. Extensive listings of OWL tools can be found at <a class="external text" href="http://semanticweb.org/wiki/Tools" rel="nofollow" title="http://semanticweb.org/wiki/Tools">semanticweb.org</a> and in the <a class="external text" href="http://esw.w3.org/topic/SemanticWebTools" rel="nofollow" title="http://esw.w3.org/topic/SemanticWebTools">ESW-Wiki</a>.
</p>
<a id="What_To_Read_Next" name="What_To_Read_Next"></a><h2> <span class="mw-headline">12 What To Read Next</span></h2>
<p>This short primer can only scratch the surface of OWL.
There are many longer and more involved tutorials on OWL and how to use
OWL tools that can be found by searching on the Web.
Reading one of these documents and using a tool to build an OWL ontology
is probably the best way to obtain a working knowledge about OWL. For learning 
more about the foundations of OWL, we recommend to consult first a textbook [<cite><a href="#ref-FOST" title="">FOST</a></cite>]
and then the original articles cited therein.
An extended introduction to the OWL 2 Profiles can be found in [<cite><a href="#ref-owlprofilesintro" title="">OWL 2 Profiles Introduction</a></cite>],
which is also available on the Web.
</p><p>This short primer is also not a normative definition of OWL.
The normative definition of the OWL syntax as well as informative
descriptions of the meaning of each OWL construct can be found in the
OWL 2 Structural Specification and Functional Syntax document 
[<cite><a href="#ref-owl-2-specification" title="">OWL 2 Specification</a></cite>].
</p><p>The OWL 2 Quick Reference Guide [<cite><a href="#ref-owl-2-quick-reference" title="">OWL 2 Quick Guide</a></cite>] comes handy as a reference when looking for information about a specific language feature.
</p><p>For those interested in more formal documents,
the formal meaning of OWL 2 can be found in the OWL 2 Semantics documents
[<cite><a href="#ref-owl-2-direct-semantics" title="">OWL 2 Direct Semantics</a></cite>] [<cite><a href="#ref-owl-2-rdf-semantics" title="">OWL 2 RDF-Based Semantics</a></cite>].
</p><p>The mapping between OWL syntax and RDF triples can be found in 
the OWL 2 Mapping to RDF Graphs document 
[<cite><a href="#ref-owl-2-rdf-mapping" title="">OWL 2 RDF Mapping</a></cite>].
</p>
<a id="Appendix:_The_Complete_Sample_Ontology" name="Appendix:_The_Complete_Sample_Ontology"></a><h2> <span class="mw-headline">13 Appendix: The Complete Sample Ontology</span></h2>
<p>Here we include the complete sample OWL ontology. Ontological axioms 
are ordered by top-level expressive features they use. Moreover, we 
follow a commonly-used ordering, with ontology and declaration 
information first, followed by information about properties, then 
classes and datatypes, then individuals.
</p><p><br>
</p>
<div class="fssyntax"><div class="exampleheader"><span class="exampleheader"><b>函数式语法</b></span></div>
<pre> Prefix(:=&lt;http://example.com/owl/families/&gt;)
 Prefix(otherOnt:=&lt;http://example.org/otherOntologies/families/&gt;)
 Prefix(xsd:=&lt;http://www.w3.org/2001/XMLSchema#&gt;)
 Prefix(owl:=&lt;http://www.w3.org/2002/07/owl#&gt;)
 Ontology(&lt;http://example.com/owl/families&gt;
   Import( &lt;http://example.org/otherOntologies/families.owl&gt; )
 
   Declaration( NamedIndividual(&nbsp;:John ) )
   Declaration( NamedIndividual(&nbsp;:Mary ) )
   Declaration( NamedIndividual(&nbsp;:Jim ) )
   Declaration( NamedIndividual(&nbsp;:James ) )
   Declaration( NamedIndividual(&nbsp;:Jack ) )
   Declaration( NamedIndividual(&nbsp;:Bill ) )
   Declaration( NamedIndividual(&nbsp;:Susan ) )
   Declaration( Class(&nbsp;:Person ) )
   AnnotationAssertion( rdfs:comment&nbsp;:Person "Represents the set of all people." )
   Declaration( Class(&nbsp;:Woman ) )
   Declaration( Class(&nbsp;:Parent ) )
   Declaration( Class(&nbsp;:Father ) )
   Declaration( Class(&nbsp;:Mother ) )
   Declaration( Class(&nbsp;:SocialRole ) )
   Declaration( Class(&nbsp;:Man ) )
   Declaration( Class(&nbsp;:Teenager ) )
   Declaration( Class(&nbsp;:ChildlessPerson ) )
   Declaration( Class(&nbsp;:Human ) )
   Declaration( Class(&nbsp;:Female ) )
   Declaration( Class(&nbsp;:HappyPerson ) )
   Declaration( Class(&nbsp;:JohnsChildren ) )
   Declaration( Class(&nbsp;:NarcisticPerson ) )
   Declaration( Class(&nbsp;:MyBirthdayGuests ) )
   Declaration( Class(&nbsp;:Dead ) )
   Declaration( Class(&nbsp;:Orphan ) )
   Declaration( Class(&nbsp;:Adult ) )
   Declaration( Class(&nbsp;:YoungChild ) )
   Declaration( ObjectProperty(&nbsp;:hasWife ) )
   Declaration( ObjectProperty(&nbsp;:hasChild ) )
   Declaration( ObjectProperty(&nbsp;:hasDaughter ) )
   Declaration( ObjectProperty(&nbsp;:loves ) )
   Declaration( ObjectProperty(&nbsp;:hasSpouse ) )
   Declaration( ObjectProperty(&nbsp;:hasGrandparent ) )
   Declaration( ObjectProperty(&nbsp;:hasParent ) )
   Declaration( ObjectProperty(&nbsp;:hasBrother ) )
   Declaration( ObjectProperty(&nbsp;:hasUncle ) )
   Declaration( ObjectProperty(&nbsp;:hasSon ) )
   Declaration( ObjectProperty(&nbsp;:hasAncestor ) )
   Declaration( ObjectProperty(&nbsp;:hasHusband ) )
   Declaration( DataProperty(&nbsp;:hasAge ) )
   Declaration( DataProperty(&nbsp;:hasSSN ) )
   Declaration( Datatype(&nbsp;:personAge ) )
   Declaration( Datatype(&nbsp;:minorAge ) )
   Declaration( Datatype(&nbsp;:majorAge ) )
   Declaration( Datatype(&nbsp;:toddlerAge ) )
 
   SubObjectPropertyOf(&nbsp;:hasWife&nbsp;:hasSpouse )
   SubObjectPropertyOf(
     ObjectPropertyChain(&nbsp;:hasParent&nbsp;:hasParent )
    &nbsp;:hasGrandparent
   )
   SubObjectPropertyOf(
     ObjectPropertyChain(&nbsp;:hasFather&nbsp;:hasBrother )
    &nbsp;:hasUncle
   )
   SubObjectPropertyOf(
    &nbsp;:hasFather
    &nbsp;:hasParent
   )
 
   EquivalentObjectProperties(&nbsp;:hasChild otherOnt:child )
   InverseObjectProperties(&nbsp;:hasParent&nbsp;:hasChild )
   EquivalentDataProperties(&nbsp;:hasAge otherOnt:age )
   DisjointObjectProperties(&nbsp;:hasSon&nbsp;:hasDaughter )
   ObjectPropertyDomain(&nbsp;:hasWife&nbsp;:Man )
   ObjectPropertyRange(&nbsp;:hasWife&nbsp;:Woman )
   DataPropertyDomain(&nbsp;:hasAge&nbsp;:Person )
   DataPropertyRange(&nbsp;:hasAge xsd:nonNegativeInteger )
 
   SymmetricObjectProperty(&nbsp;:hasSpouse )
   AsymmetricObjectProperty(&nbsp;:hasChild )
   DisjointObjectProperties(&nbsp;:hasParent&nbsp;:hasSpouse )
   ReflexiveObjectProperty(&nbsp;:hasRelative )
   IrreflexiveObjectProperty(&nbsp;:parentOf )
   FunctionalObjectProperty(&nbsp;:hasHusband )
   InverseFunctionalObjectProperty(&nbsp;:hasHusband )
   TransitiveObjectProperty(&nbsp;:hasAncestor )
   FunctionalDataProperty(&nbsp;:hasAge )
 
   SubClassOf(&nbsp;:Woman&nbsp;:Person )
   SubClassOf(&nbsp;:Mother&nbsp;:Woman )
   SubClassOf(
    &nbsp;:Grandfather
     ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
   )
   SubClassOf(
    &nbsp;:Teenager
     DataSomeValuesFrom(&nbsp;:hasAge
       DatatypeRestriction( xsd:integer
         xsd:minExclusive "12"^^xsd:integer
         xsd:maxInclusive "19"^^xsd:integer
       )
     )
   )
   SubClassOf(
     Annotation( rdfs:comment "States that every man is a person." )
    &nbsp;:Man
    &nbsp;:Person
   )
   SubClassOf(
    &nbsp;:Father
     ObjectIntersectionOf(&nbsp;:Man&nbsp;:Parent )
   )
   SubClassOf(
    &nbsp;:ChildlessPerson
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(
         ObjectSomeValuesFrom(
           ObjectInverseOf(&nbsp;:hasParent )
           owl:Thing
         )
       )
     )
   )
   SubClassOf(
     ObjectIntersectionOf(
       ObjectOneOf(&nbsp;:Mary&nbsp;:Bill&nbsp;:Meg )
      &nbsp;:Female
     )
     ObjectIntersectionOf(
      &nbsp;:Parent
       ObjectMaxCardinality( 1&nbsp;:hasChild )
       ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:Female )
     )
   )
 
   EquivalentClasses(&nbsp;:Person&nbsp;:Human )
   EquivalentClasses(
    &nbsp;:Mother
     ObjectIntersectionOf(&nbsp;:Woman&nbsp;:Parent )
   )
   EquivalentClasses(
    &nbsp;:Parent
     ObjectUnionOf(&nbsp;:Mother&nbsp;:Father )
   )
   EquivalentClasses(
    &nbsp;:ChildlessPerson
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(&nbsp;:Parent )
     )
   )
   EquivalentClasses(
    &nbsp;:Parent 
     ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:Person )
   )
   EquivalentClasses(
    &nbsp;:HappyPerson
     ObjectIntersectionOf(
        ObjectAllValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
        ObjectSomeValuesFrom(&nbsp;:hasChild&nbsp;:HappyPerson )
     )
   )
   EquivalentClasses(
    &nbsp;:JohnsChildren
     ObjectHasValue(&nbsp;:hasParent&nbsp;:John )
   )
   EquivalentClasses(
    &nbsp;:NarcisticPerson
     ObjectHasSelf(&nbsp;:loves )
   )
   EquivalentClasses(
    &nbsp;:MyBirthdayGuests
     ObjectOneOf(&nbsp;:Bill&nbsp;:John&nbsp;:Mary)
   )
   EquivalentClasses(
    &nbsp;:Orphan
     ObjectAllValuesFrom(
       ObjectInverseOf(&nbsp;:hasChild )
      &nbsp;:Dead
     )
   )
   EquivalentClasses(&nbsp;:Adult otherOnt:Grownup )
   EquivalentClasses(
    &nbsp;:Parent
     ObjectSomeValuesFrom(
      &nbsp;:hasChild
      &nbsp;:Person
     )
   )
 
   DisjointClasses(&nbsp;:Woman&nbsp;:Man )
   DisjointClasses(
    &nbsp;:Mother
    &nbsp;:Father
    &nbsp;:YoungChild
   )
   HasKey(&nbsp;:Person () (&nbsp;:hasSSN ) )
 
   DatatypeDefinition(
    &nbsp;:personAge
     DatatypeRestriction( xsd:integer
       xsd:minInclusive "0"^^xsd:integer
       xsd:maxInclusive "150"^^xsd:integer
     )
   )
   DatatypeDefinition(
    &nbsp;:minorAge
     DatatypeRestriction( xsd:integer
       xsd:minInclusive "0"^^xsd:integer
       xsd:maxInclusive "18"^^xsd:integer
     )
   )
   DatatypeDefinition(
    &nbsp;:majorAge
     DataIntersectionOf(
      &nbsp;:personAge
       DataComplementOf(&nbsp;:minorAge )
     )
   )
   DatatypeDefinition(
    &nbsp;:toddlerAge
     DataOneOf( "1"^^xsd:integer "2"^^xsd:integer ) 
   )
 
   ClassAssertion(&nbsp;:Person&nbsp;:Mary )
   ClassAssertion(&nbsp;:Woman&nbsp;:Mary )
   ClassAssertion(
     ObjectIntersectionOf(
      &nbsp;:Person
       ObjectComplementOf(&nbsp;:Parent )
     )
    &nbsp;:Jack
   )
   ClassAssertion(
     ObjectMaxCardinality( 4&nbsp;:hasChild&nbsp;:Parent )
    &nbsp;:John
   )
   ClassAssertion(
     ObjectMinCardinality( 2&nbsp;:hasChild&nbsp;:Parent )
    &nbsp;:John
   )
   ClassAssertion(
     ObjectExactCardinality( 3&nbsp;:hasChild&nbsp;:Parent ) 
    &nbsp;:John
   )
   ClassAssertion(
     ObjectExactCardinality( 5&nbsp;:hasChild )
    &nbsp;:John
   )
   ClassAssertion(&nbsp;:Father&nbsp;:John )
   ClassAssertion(&nbsp;:SocialRole&nbsp;:Father )
 
   ObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:John&nbsp;:Mary )
   NegativeObjectPropertyAssertion(&nbsp;:hasWife&nbsp;:Bill&nbsp;:Mary )
   NegativeObjectPropertyAssertion(
    &nbsp;:hasDaughter
    &nbsp;:Bill
    &nbsp;:Susan
   )
   DataPropertyAssertion(&nbsp;:hasAge&nbsp;:John "51"^^xsd:integer )
   NegativeDataPropertyAssertion(&nbsp;:hasAge&nbsp;:Jack "53"^^xsd:integer )
 
   SameIndividual(&nbsp;:James&nbsp;:Jim )
   SameIndividual(&nbsp;:John otherOnt:JohnBrown )
   SameIndividual(&nbsp;:Mary otherOnt:MaryBrown )
   DifferentIndividuals(&nbsp;:John&nbsp;:Bill )
 )
</pre>
</div><div class="rdfxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>RDF/XML 语法</b></span></div>
<pre>&lt;!DOCTYPE rdf:RDF [
    &lt;!ENTITY owl "http://www.w3.org/2002/07/owl#" &gt;
    &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
    &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
    &lt;!ENTITY otherOnt "http://example.org/otherOntologies/families/" &gt;
]&gt;
 
 &lt;rdf:RDF xml:base="http://example.com/owl/families/"
   xmlns="http://example.com/owl/families/"
   xmlns:otherOnt="http://example.org/otherOntologies/families/"
   xmlns:owl="http://www.w3.org/2002/07/owl#"
   xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema#"&gt;
 
   &lt;owl:Ontology rdf:about="http://example.com/owl/families"&gt;
     &lt;owl:imports rdf:resource="http://example.org/otherOntologies/families.owl" /&gt;
   &lt;/owl:Ontology&gt;
 
 
   &lt;owl:ObjectProperty rdf:about="hasWife"&gt;
     &lt;rdfs:subPropertyOf rdf:resource="hasSpouse"/&gt;
     &lt;rdfs:domain rdf:resource="Man"/&gt;
     &lt;rdfs:range rdf:resource="Woman"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasParent"&gt;
     &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
     &lt;owl:propertyDisjointWith rdf:resource="hasSpouse"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasSon"&gt;
     &lt;owl:propertyDisjointWith rdf:resource="hasDaughter"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:ObjectProperty rdf:about="hasFather"&gt;
     &lt;rdfs:subPropertyOf rdf:resource="hasParent"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:SymmetricProperty rdf:about="hasSpouse"/&gt;
   &lt;owl:AsymmetricProperty rdf:about="hasChild"/&gt;
   &lt;owl:ReflexiveProperty rdf:about="hasRelative"/&gt;
   &lt;owl:IrreflexiveProperty rdf:about="parentOf"/&gt;
   &lt;owl:FunctionalProperty rdf:about="hasHusband"/&gt;
   &lt;owl:InverseFunctionalProperty rdf:about="hasHusband"/&gt;
   &lt;owl:TransitiveProperty rdf:about="hasAncestor"/&gt;
 
   &lt;rdf:Description rdf:about="hasGrandparent"&gt;
     &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
       &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
       &lt;owl:ObjectProperty rdf:about="hasParent"/&gt;
     &lt;/owl:propertyChainAxiom&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="hasUncle"&gt;
     &lt;owl:propertyChainAxiom rdf:parseType="Collection"&gt;
       &lt;owl:ObjectProperty rdf:about="hasFather"/&gt;
       &lt;owl:ObjectProperty rdf:about="hasBrother"/&gt;
     &lt;/owl:propertyChainAxiom&gt;
   &lt;/rdf:Description&gt;

   &lt;owl:ObjectProperty rdf:about="hasChild"&gt;
     &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;child"/&gt;
   &lt;/owl:ObjectProperty&gt;
 
   &lt;owl:DatatypeProperty rdf:about="hasAge"&gt;
     &lt;rdfs:domain rdf:resource="Person"/&gt;
     &lt;rdfs:range rdf:resource="&amp;xsd;nonNegativeInteger"/&gt;
     &lt;owl:equivalentProperty rdf:resource="&amp;otherOnt;age"/&gt;
   &lt;/owl:DatatypeProperty&gt;
   &lt;owl:FunctionalProperty rdf:about="hasAge"/&gt;
 
   &lt;owl:Class rdf:about="Woman"&gt;
     &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Mother"&gt;
     &lt;rdfs:subClassOf rdf:resource="Woman"/&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Woman"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Person"&gt;
     &lt;rdfs:comment&gt;Represents the set of all people.&lt;/rdfs:comment&gt;
     &lt;owl:equivalentClass rdf:resource="Human"/&gt;
     &lt;owl:hasKey rdf:parseType="Collection"&gt;
       &lt;owl:DataProperty rdf:about="hasSSN"/&gt;
     &lt;/owl:hasKey&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Parent"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:unionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Mother"/&gt;
           &lt;owl:Class rdf:about="Father"/&gt;
         &lt;/owl:unionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:someValuesFrom rdf:resource="Person"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="ChildlessPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf rdf:resource="Parent"/&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Grandfather"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Man"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="HappyPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:allValuesFrom rdf:resource="HappyPerson"/&gt;
           &lt;/owl:Restriction&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:someValuesFrom rdf:resource="HappyPerson"/&gt;
           &lt;/owl:Restriction&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="JohnsChildren"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasParent"/&gt;
         &lt;owl:hasValue rdf:resource="John"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="NarcisticPerson"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="loves"/&gt;
         &lt;owl:hasSelf rdf:datatype="&amp;xsd;boolean"&gt;
           true
         &lt;/owl:hasSelf&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="MyBirthdayGuests"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Class&gt;
         &lt;owl:oneOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="Bill"/&gt;
           &lt;rdf:Description rdf:about="John"/&gt;
           &lt;rdf:Description rdf:about="Mary"/&gt;
         &lt;/owl:oneOf&gt;
       &lt;/owl:Class&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Orphan"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty&gt;
           &lt;owl:ObjectProperty&gt;
             &lt;owl:inverseOf rdf:resource="hasChild"/&gt;
           &lt;/owl:ObjectProperty&gt;
         &lt;/owl:onProperty&gt;
         &lt;owl:allValuesFrom rdf:resource="Dead"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Teenager"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:onProperty rdf:resource="hasAge"/&gt;
         &lt;owl:someValuesFrom&gt;
           &lt;rdfs:Datatype&gt;
             &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
             &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
               &lt;rdf:Description&gt;
                 &lt;xsd:minExclusive rdf:datatype="&amp;xsd;integer"&gt;12&lt;/xsd:minExclusive&gt;
               &lt;/rdf:Description&gt;
               &lt;rdf:Description&gt;
                 &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;19&lt;/xsd:maxInclusive&gt;
               &lt;/rdf:Description&gt;
             &lt;/owl:withRestrictions&gt;
           &lt;/rdfs:Datatype&gt;
         &lt;/owl:someValuesFrom&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Man"&gt;
     &lt;rdfs:subClassOf rdf:resource="Person"/&gt;
   &lt;/owl:Class&gt;
   &lt;owl:Axiom&gt;
     &lt;owl:annotatedSource rdf:resource="Man"/&gt;
     &lt;owl:annotatedProperty rdf:resource="&amp;rdfs;subClassOf"/&gt;
     &lt;owl:annotatedTarget rdf:resource="Person"/&gt;
     &lt;rdfs:comment&gt;States that every man is a person.&lt;/rdfs:comment&gt;
   &lt;/owl:Axiom&gt;
 
   &lt;owl:Class rdf:about="Adult"&gt;
     &lt;owl:equivalentClass rdf:resource="&amp;otherOnt;Grownup"/&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="Father"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Man"/&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class rdf:about="ChildlessPerson"&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf&gt;
               &lt;owl:Restriction&gt;
                 &lt;owl:onProperty&gt;
                   &lt;owl:ObjectProperty&gt;
                     &lt;owl:inverseOf rdf:resource="hasParent"/&gt;
                   &lt;/owl:ObjectProperty&gt;
                 &lt;/owl:onProperty&gt;
                 &lt;owl:someValuesFrom rdf:resource="&amp;owl;Thing"/&gt;
               &lt;/owl:Restriction&gt;
             &lt;/owl:complementOf&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:Class&gt;
     &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
       &lt;owl:Class&gt;
         &lt;owl:oneOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="Mary"/&gt;
           &lt;rdf:Description rdf:about="Bill"/&gt;
           &lt;rdf:Description rdf:about="Meg"/&gt;
         &lt;/owl:oneOf&gt;
       &lt;/owl:Class&gt;
       &lt;owl:Class rdf:about="Female"/&gt;
     &lt;/owl:intersectionOf&gt;
     &lt;rdfs:subClassOf&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Parent"/&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:maxCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
               1
             &lt;/owl:maxCardinality&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
           &lt;/owl:Restriction&gt;
           &lt;owl:Restriction&gt;
             &lt;owl:onProperty rdf:resource="hasChild"/&gt;
             &lt;owl:allValuesFrom rdf:resource="Female"/&gt;
           &lt;/owl:Restriction&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdfs:subClassOf&gt;
   &lt;/owl:Class&gt;
 
   &lt;owl:AllDisjointClasses&gt;
     &lt;owl:members rdf:parseType="Collection"&gt;
       &lt;owl:Class rdf:about="Woman"/&gt;
       &lt;owl:Class rdf:about="Man"/&gt;
     &lt;/owl:members&gt;
   &lt;/owl:AllDisjointClasses&gt;
 
   &lt;owl:AllDisjointClasses&gt;
     &lt;owl:members rdf:parseType="Collection"&gt;
       &lt;owl:Class rdf:about="Mother"/&gt;
       &lt;owl:Class rdf:about="Father"/&gt;
       &lt;owl:Class rdf:about="YoungChild"/&gt;
     &lt;/owl:members&gt;
   &lt;/owl:AllDisjointClasses&gt;
 
 
   &lt;rdf:Description rdf:about="personAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
         &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:minInclusive rdf:datatype="&amp;xsd;integer"&gt;0&lt;/xsd:minInclusive&gt;
           &lt;/rdf:Description&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;150&lt;/xsd:maxInclusive&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:withRestrictions&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;

   &lt;rdf:Description rdf:about="minorAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:onDatatype rdf:resource="&amp;xsd;integer"/&gt;
         &lt;owl:withRestrictions rdf:parseType="Collection"&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:minInclusive rdf:datatype="&amp;xsd;integer"&gt;0&lt;/xsd:minInclusive&gt;
           &lt;/rdf:Description&gt;
           &lt;rdf:Description&gt;
             &lt;xsd:maxInclusive rdf:datatype="&amp;xsd;integer"&gt;18&lt;/xsd:maxInclusive&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:withRestrictions&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="majorAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:intersectionOf rdf:parseType="Collection"&gt;
           &lt;rdf:Description rdf:about="personAge"/&gt;
           &lt;rdfs:Datatype&gt;
             &lt;owl:datatypeComplementOf rdf:resource="minorAge"/&gt;
           &lt;/rdfs:Datatype&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
   &lt;rdf:Description rdf:about="toddlerAge"&gt;
     &lt;owl:equivalentClass&gt;
       &lt;rdfs:Datatype&gt;
         &lt;owl:oneOf&gt;
           &lt;rdf:Description&gt;
             &lt;rdf:first rdf:datatype="&amp;xsd;integer"&gt;1&lt;/rdf:first&gt;
             &lt;rdf:rest&gt;
               &lt;rdf:Description&gt;
                 &lt;rdf:first rdf:datatype="&amp;xsd;integer"&gt;2&lt;/rdf:first&gt;
                 &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt;
               &lt;/rdf:Description&gt;
             &lt;/rdf:rest&gt;
           &lt;/rdf:Description&gt;
         &lt;/owl:oneOf&gt;
       &lt;/rdfs:Datatype&gt;
     &lt;/owl:equivalentClass&gt;
   &lt;/rdf:Description&gt;
 
 
   &lt;Person rdf:about="Mary"&gt;
     &lt;rdf:type rdf:resource="Woman"/&gt;
     &lt;owl:sameAs rdf:resource="&amp;otherOnt;MaryBrown"/&gt;
   &lt;/Person&gt;
 
   &lt;owl:NamedIndividual rdf:about="James"&gt;
     &lt;owl:sameAs rdf:resource="Jim"/&gt;
   &lt;/owl:NamedIndividual&gt;
 
   &lt;rdf:Description rdf:about="Jack"&gt;
     &lt;rdf:type&gt;
       &lt;owl:Class&gt;
         &lt;owl:intersectionOf  rdf:parseType="Collection"&gt;
           &lt;owl:Class rdf:about="Person"/&gt;
           &lt;owl:Class&gt;
             &lt;owl:complementOf rdf:resource="Parent"/&gt;
           &lt;/owl:Class&gt;
         &lt;/owl:intersectionOf&gt;
       &lt;/owl:Class&gt;
     &lt;/rdf:type&gt;
   &lt;/rdf:Description&gt;
 
   &lt;owl:NamedIndividual rdf:about="John"&gt;
     &lt;hasWife rdf:resource="Mary"/&gt;
     &lt;hasAge rdf:datatype="&amp;xsd;integer"&gt;51&lt;/hasAge&gt;
     &lt;owl:differentFrom rdf:resource="Bill"/&gt;
     &lt;owl:sameAs rdf:resource="&amp;otherOnt;JohnBrown"/&gt;
     &lt;rdf:type rdf:resource="Father"/&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:maxQualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           4
         &lt;/owl:maxQualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:minQualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           2
         &lt;/owl:minQualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:qualifiedCardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           3
         &lt;/owl:qualifiedCardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
         &lt;owl:onClass rdf:resource="Parent"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
     &lt;rdf:type&gt;
       &lt;owl:Restriction&gt;
         &lt;owl:cardinality rdf:datatype="&amp;xsd;nonNegativeInteger"&gt;
           5
         &lt;/owl:cardinality&gt;
         &lt;owl:onProperty rdf:resource="hasChild"/&gt;
       &lt;/owl:Restriction&gt;
     &lt;/rdf:type&gt;
   &lt;/owl:NamedIndividual&gt;
 
   &lt;SocialRole rdf:about="Father"/&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasWife"/&gt;
     &lt;owl:targetIndividual rdf:resource="Mary"/&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Jack"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasAge"/&gt;
     &lt;owl:targetValue rdf:datatype="&amp;xsd;integer"&gt;53&lt;/owl:targetValue&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 
   &lt;owl:NegativePropertyAssertion&gt;
     &lt;owl:sourceIndividual rdf:resource="Bill"/&gt;
     &lt;owl:assertionProperty rdf:resource="hasDaughter"/&gt;
     &lt;owl:targetIndividual rdf:resource="Susan"/&gt;
   &lt;/owl:NegativePropertyAssertion&gt;
 &lt;/rdf:RDF&gt;
</pre>
</div><div class="turtle" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>Turtle 语法</b></span></div>
<pre>@prefix&nbsp;: &lt;http://example.com/owl/families/&gt; .
@prefix otherOnt: &lt;http://example.org/otherOntologies/families/&gt; .
@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

&lt;http://example.com/owl/families&gt; 
     rdf:type owl:Ontology&nbsp;;
     owl:imports &lt;http://example.org/otherOntologies/families.owl&gt; .

:hasSpouse    rdf:type  owl:SymmetricProperty .
:hasRelative  rdf:type  owl:ReflexiveProperty .
:parentOf     rdf:type  owl:IrreflexiveProperty .
:hasAncestor  rdf:type  owl:TransitiveProperty .

:hasHusband   rdf:type  owl:FunctionalProperty .
:hasHusband   rdf:type  owl:InverseFunctionalProperty .

:hasWife rdf:type           owl:ObjectProperty .
:hasWife rdfs:domain       &nbsp;:Man&nbsp;;
         rdfs:range        &nbsp;:Woman .
:hasWife rdfs:subPropertyOf&nbsp;:hasSpouse .

:hasSon     owl:propertyDisjointWith &nbsp;:hasDaughter.
:hasFather  rdfs:subPropertyOf       &nbsp;:hasParent.
 
:hasParent owl:inverseOf            &nbsp;:hasChild .
:hasParent owl:propertyDisjointWith &nbsp;:hasSpouse .

:hasGrandparent  owl:propertyChainAxiom  (&nbsp;:hasParent &nbsp;:hasParent ) .
:hasUncle        owl:propertyChainAxiom  (&nbsp;:hasFather &nbsp;:hasBrother ) .

:hasAge  owl:equivalentProperty  otherOnt:age .
:hasAge  rdf:type                owl:DatatypeProperty .
:hasAge  rdf:type                owl:FunctionalProperty .
:hasAge  rdfs:domain            &nbsp;:Person&nbsp;;
         rdfs:range              xsd:nonNegativeInteger .

:hasChild  owl:equivalentProperty  otherOnt:child .
:hasChild  rdf:type                owl:AsymmetricProperty .

:Woman   rdfs:subClassOf&nbsp;:Person .

:Mother  rdfs:subClassOf&nbsp;:Woman .
:Mother  owl:equivalentClass  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Woman&nbsp;:Parent ) 
] .

:Person  rdf:type            owl:Class .
:Person  owl:equivalentClass&nbsp;:Human .
:Person  rdfs:comment        "Represents the set of all people."^^xsd:string .
:Person  owl:hasKey          (&nbsp;:hasSSN ) .
:hasSSN  rdf:type            owl:DataProperty .
:Parent  owl:equivalentClass [
  rdf:type     owl:Class&nbsp;;
  owl:unionOf  (&nbsp;:Mother&nbsp;:Father )
] .

:Parent  owl:equivalentClass  [
  rdf:type            owl:Restriction&nbsp;;
  owl:onProperty     &nbsp;:hasChild&nbsp;;
  owl:someValuesFrom &nbsp;:Person
] .

:Grandfather  rdfs:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
] .

:HappyPerson
    owl:equivalentClass  [
      rdf:type            owl:Class&nbsp;;
      owl:intersectionOf  ( [ rdf:type            owl:Restriction&nbsp;;
                              owl:onProperty     &nbsp;:hasChild&nbsp;;
                              owl:allValuesFrom  &nbsp;:HappyPerson      ]
                            [ rdf:type            owl:Restriction&nbsp;;
                              owl:onProperty     &nbsp;:hasChild&nbsp;;
                              owl:someValuesFrom &nbsp;:HappyPerson      ]
                          )
    ] .

:JohnsChildren  owl:equivalentClass  [
  rdf:type        owl:Restriction&nbsp;;
  owl:onProperty &nbsp;:hasParent&nbsp;;
  owl:hasValue   &nbsp;:John
] .

:NarcisticPerson owl:equivalentClass  [
  rdf:type        owl:Restriction&nbsp;;
  owl:onProperty &nbsp;:loves&nbsp;;
  owl:hasSelf     "true"^^xsd:boolean .
] .

:MyBirthdayGuests  owl:equivalentClass  [
  rdf:type   owl:Class&nbsp;;
  owl:oneOf  (&nbsp;:Bill &nbsp;:John &nbsp;:Mary )
] .
:Orphan  owl:equivalentClass  [
  rdf:type           owl:Restriction&nbsp;;
  owl:onProperty     [ owl:inverseOf &nbsp;:hasChild ]&nbsp;;
  owl:allValuesFrom &nbsp;:Dead 
] .

:Teenager  rdfs:subClassOf
      [ rdf:type             owl:Restriction&nbsp;;
        owl:onProperty      &nbsp;:hasAge&nbsp;;
        owl:someValuesFrom
         [ rdf:type             rdfs:Datatype&nbsp;;
           owl:onDatatype       xsd:integer&nbsp;;
           owl:withRestrictions (  [ xsd:minExclusive     "12"^^xsd:integer ]
                                   [ xsd:maxInclusive     "19"^^xsd:integer ]
           )
         ]
      ] .

:Man rdfs:subClassOf       &nbsp;:Person .
[]   rdf:type               owl:Axiom&nbsp;;
     owl:annotatedSource   &nbsp;:Man&nbsp;;
     owl:annotatedProperty  rdfs:subClassOf&nbsp;;
     owl:annotatedTarget   &nbsp;:Person&nbsp;;
     rdfs:comment           "States that every man is a person."^^xsd:string .

:Adult owl:equivalentClass otherOnt:Grownup .

:Father rdfs:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Man &nbsp;:Parent )
] .

:ChildlessPerson      owl:equivalentClass  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person  [ owl:complementOf &nbsp;:Parent ] ) 
] .
:ChildlessPerson      owl:subClassOf  [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person
                        [ owl:complementOf  [
                            rdf:type            owl:Restriction&nbsp;;
                            owl:onProperty      [ owl:inverseOf &nbsp;:hasParent ]&nbsp;;
                            owl:someValuesFrom  owl:Thing
                          ]
                        ]
                      )
] .

[]  rdf:type            owl:Class&nbsp;;
    owl:intersectionOf  ( [ rdf:type   owl:Class&nbsp;;
                            owl:oneOf  (&nbsp;:Mary &nbsp;:Bill &nbsp;:Meg ) ]
                         &nbsp;:Female 
                        )&nbsp;;
    rdfs:subClassOf     [
      rdf:type            owl:Class&nbsp;;
      owl:intersectionOf  (&nbsp;:Parent  
                            [ rdf:type            owl:Restriction&nbsp;;
                              owl:maxCardinality  "1"^^xsd:nonNegativeInteger&nbsp;;
                              owl:onProperty     &nbsp;:hasChild ]
                            [ rdf:type           owl:Restriction&nbsp;;
                              owl:onProperty    &nbsp;:hasChild&nbsp;;
                              owl:allValuesFrom &nbsp;:Female ]
                          )
    ] .

[] rdf:type     owl:AllDisjointClasses&nbsp;;
   owl:members  (&nbsp;:Mother &nbsp;:Father &nbsp;:YoungChild ) .

[] rdf:type     owl:AllDisjointClasses&nbsp;;
   owl:members  (&nbsp;:Woman &nbsp;:Man ) .

:personAge  owl:equivalentClass
 [ rdf:type       rdfs:Datatype;
   owl:onDatatype xsd:integer;
   owl:withRestrictions (
      [ xsd:minInclusive "0"^^xsd:integer ]
      [ xsd:maxInclusive "150"^^xsd:integer ] 
   )
 ] .
</pre>
<pre>:minorAge  owl:equivalentClass
 [ rdf:type       rdfs:Datatype;
   owl:onDatatype xsd:integer;
   owl:withRestrictions (
      [ xsd:minInclusive "0"^^xsd:integer ]
      [ xsd:maxInclusive "18"^^xsd:integer ] 
   )
 ] .
</pre>
<pre>:majorAge  owl:equivalentClass
  [ rdf:type           rdfs:Datatype;
    owl:intersectionOf (
      &nbsp;:personAge
       [ rdf:type rdfs:Datatype;
         owl:datatypeComplementOf&nbsp;:minorAge ] 
    )
  ] .

:toddlerAge  owl:equivalentClass
  [ rdf:type  rdfs:Datatype;
    owl:oneOf (  "1"^^xsd:integer  "2"^^xsd:integer )
  ] .

:Mary rdf:type  &nbsp;:Person .
:Mary rdf:type  &nbsp;:Woman .
:Mary owl:sameAs otherOnt:MaryBrown .

:James owl:sameAs&nbsp;:Jim .

:Jack  rdf:type          [
  rdf:type            owl:Class&nbsp;;
  owl:intersectionOf  (&nbsp;:Person  
                        [ rdf:type          owl:Class&nbsp;;
                          owl:complementOf &nbsp;:Parent     ]
                      )
] .

:John  owl:sameAs        otherOnt:JohnBrown .
:John  rdf:type          owl:NamedIndividual .
:John  rdf:type         &nbsp;:Father .
:John &nbsp;:hasWife         &nbsp;:Mary .
:John  owl:differentFrom&nbsp;:Bill .
:John &nbsp;:hasAge           51 .
:John  rdf:type  [
  rdf:type                     owl:Restriction&nbsp;;
  owl:maxQualifiedCardinality  "4"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty              &nbsp;:hasChild&nbsp;;
  owl:onClass                 &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type                     owl:Restriction&nbsp;;
  owl:minQualifiedCardinality  "2"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty              &nbsp;:hasChild&nbsp;;
  owl:onClass                 &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type                  owl:Restriction&nbsp;;
  owl:qualifiedCardinality  "3"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty           &nbsp;:hasChild&nbsp;;
  owl:onClass              &nbsp;:Parent
] .
:John  rdf:type  [
  rdf:type         owl:Restriction&nbsp;;
  owl:cardinality  "5"^^xsd:nonNegativeInteger&nbsp;;
  owl:onProperty  &nbsp;:hasChild
] .

:Father rdf:type&nbsp;:SocialRole .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Bill&nbsp;;
    owl:assertionProperty &nbsp;:hasWife&nbsp;;
    owl:targetIndividual  &nbsp;:Mary .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Bill&nbsp;;
    owl:assertionProperty &nbsp;:hasDaughter&nbsp;;
    owl:targetIndividual  &nbsp;:Susan .

[]  rdf:type               owl:NegativePropertyAssertion&nbsp;;
    owl:sourceIndividual  &nbsp;:Jack&nbsp;;
    owl:assertionProperty &nbsp;:hasAge&nbsp;;
    owl:targetValue        53 .
</pre>
</div><div class="manchester" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>曼彻斯特语法</b></span></div>
<pre>Prefix:&nbsp;: &lt;http://example.com/owl/families/&gt;
Prefix: xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
Prefix: owl: &lt;http://www.w3.org/2002/07/owl#&gt;
Prefix: otherOnt: &lt;http://example.org/otherOntologies/families/&gt;
Ontology: &lt;http://example.com/owl/families&gt;
Import: &lt;http://example.org/otherOntologies/families.owl&gt;

ObjectProperty: hasWife
  SubPropertyOf: hasSpouse
  Domain:        Man
  Range:         Woman
ObjectProperty: hasParent
  InverseOf: hasChild
ObjectProperty: hasSpouse
  Characteristics: Symmetric
ObjectProperty: hasChild
  Characteristics: Asymmetric
ObjectProperty: hasRelative
  Characteristics: Reflexive
ObjectProperty: parentOf
  Characteristics: Irreflexive
ObjectProperty: hasHusband
  Characteristics: Functional
  Characteristics: InverseFunctional
ObjectProperty: hasAncestor
  Characteristics: Transitive
ObjectProperty: hasGrandparent
  SubPropertyChain: hasParent o hasParent
ObjectProperty: hasUncle
  SubPropertyChain: hasFather o hasBrother
ObjectProperty: hasFather
  SubPropertyOf: hasParent
ObjectProperty: hasBrother
ObjectProperty: hasDaughter
ObjectProperty: hasSon
ObjectProperty: loves

DisjointProperties: hasParent, hasSpouse
DisjointProperties: hasSon,    hasDaughter
EquivalentProperties: hasChild, otherOnt:child
EquivalentProperties: hasAge,   otherOnt:age

DataProperty: hasAge
  Domain: Person
  Range:  xsd:nonNegativeInteger
  Characteristics: Functional
DataProperty: hasSSN

Datatype: personAge
  EquivalentTo: integer[&lt;= 0 , &gt;= 150]
Datatype: minorAge
  EquivalentTo: integer[&lt;= 0 , &gt;= 18]
Datatype: majorAge
   EquivalentTo: personAge and not minorAge
Datatype: toddlerAge
   EquivalentTo: { 1, 2 }
Datatype: minorAge

Class: Woman
  SubClassOf: Person
Class: Mother
  SubClassOf:   Woman
  EquivalentTo: Woman and Parent
Class: Person
  Annotations:  rdfs:comment "Represents the set of all people."
  EquivalentTo: Human
  HasKey: hasSSN
Class: Parent
  EquivalentTo: hasChild some Person
  EquivalentTo: Mother or Father
Class: ChildlessPerson
  EquivalentTo: Person and not Parent
  SubClassOf:   Person and not (inverse hasParent some owl:Thing)
Class: Grandfather
  SubClassOf: Man and Parent
Class: HappyPerson
  EquivalentTo: hasChild only Happy and hasChild some Happy
Class: JohnsChildren
  EquivalentTo: hasParent value John
Class: NarcisticPerson
  EquivalentTo: loves Self
Class: Orphan
  EquivalentTo: inverse hasChild only Dead
Class: Teenager
 SubClassOf: hasAge some integer[&lt;= 13 , &gt;= 19]
Class: Man
  SubClassOf: Annotations: rdfs:comment "States that every man is a person." Person
Class: MyBirthdayGuests
  EquivalentTo: { Bill, John, Mary }
Class: Father
  SubClassOf: Man and Parent
Class: X
  SubClassOf:   Parent and hasChild max 1 and hasChild only Female
  EquivalentTo: {Mary, Bill, Meg} and Female
Class: Adult
Class: Dead
Class: Father
Class: Female
Class: Happy
Class: Human
Class: SocialRole
Class: YoungChild

DisjointClasses: Mother, Father, YoungChild
DisjointClasses: Woman, Man
EquivalentClasses: Adult, otherOnt:Grownup

Individual: Mary
  Types: Person
  Types: Woman
Individual: Jack
  Types: Person and not Parent
Individual: John
  Types: Father
  Types: hasChild max 4 Parent
  Types: hasChild min 2 Parent
  Types: hasChild exactly 3 Parent
  Types: hasChild exactly 5
  Facts: hasAge "51"^^xsd:integer
  Facts: hasWife Mary
  DifferentFrom: Bill 
Individual: Bill
  Facts: not hasWife     Mary
  Facts: not hasDaughter Susan
Individual: James 
  SameAs: Jim
Individual: Jack
  Facts: not hasAge "53"^^xsd:integer
Individual: Father
 Types: SocialRole
Individual: Meg
Individual: Susan
Individual: Jim
Individual: otherOnt:JohnBrown
Individual: otherOnt:MaryBrown

SameIndividual: John, otherOnt:JohnBrown 
SameIndividual: Mary, otherOnt:MaryBrown
</pre>
</div><div class="owlxml" style="display: none;"><div class="exampleheader"><span class="exampleheader"><b>OWL/XML 语法</b></span></div>
<pre>&lt;!DOCTYPE Ontology [
   &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#" &gt;
   &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" &gt;
]&gt;

 &lt;Ontology
   xml:base="http://example.com/owl/families/"
   ontologyIRI="http://example.com/owl/families"
   xmlns="http://www.w3.org/2002/07/owl#"&gt;
   &lt;Prefix name="owl" IRI="http://www.w3.org/2002/07/owl#"/&gt;
   &lt;Prefix name="otherOnt" IRI="http://example.org/otherOntologies/families/"/&gt;
   &lt;Import&gt;http://example.org/otherOntologies/families.owl&lt;/Import&gt;

   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Jim"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="James"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Susan"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;NamedIndividual IRI="Meg"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/Declaration&gt;
   &lt;AnnotationAssertion&gt;
     &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
     &lt;IRI&gt;Person&lt;/IRI&gt;
     &lt;Literal&gt;Represents the set of all people.&lt;/Literal&gt;
   &lt;/AnnotationAssertion&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Parent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Father"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Mother"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="SocialRole"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Man"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Teenager"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Human"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Female"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="HappyPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="JohnsChildren"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="NarcisticPerson"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="MyBirthdayGuests"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Dead"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Orphan"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="Adult"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Class IRI="YoungChild"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="loves"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasGrandparent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasBrother"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasSon"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasAncestor"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;DataProperty IRI="hasSSN"/&gt;
   &lt;/Declaration&gt;

   &lt;Declaration&gt;
     &lt;Datatype IRI="personAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="minorAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="majorAge"/&gt;
   &lt;/Declaration&gt;
   &lt;Declaration&gt;
     &lt;Datatype IRI="toddlerAge"/&gt;
   &lt;/Declaration&gt;

   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="personAge"/&gt;
     &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="&amp;xsd;integer"/&gt;
       &lt;FacetRestriction facet="&amp;xsd;minInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;150&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
     &lt;/DatatypeRestriction&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="minorAge"/&gt;
     &lt;DatatypeRestriction&gt;
       &lt;Datatype IRI="&amp;xsd;integer"/&gt;
       &lt;FacetRestriction facet="&amp;xsd;minInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;0&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
       &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
         &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;18&lt;/Literal&gt;
       &lt;/FacetRestriction&gt;
     &lt;/DatatypeRestriction&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="majorAge"/&gt;
     &lt;DataIntersectionOf&gt;
       &lt;Datatype IRI="personAge"/&gt;
       &lt;DataComplementOf&gt;
         &lt;Datatype IRI="minorAge"/&gt;
       &lt;/DataComplementOf&gt;
     &lt;/DataIntersectionOf&gt;
   &lt;/DatatypeDefinition&gt;
   &lt;DatatypeDefinition&gt;
     &lt;Datatype IRI="toddlerAge"/&gt;
     &lt;DataOneOf&gt;
       &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;1&lt;/Literal&gt; 
       &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;2&lt;/Literal&gt;
     &lt;/DataOneOf&gt;
   &lt;/DatatypeDefinition&gt;
 
   &lt;SymmetricObjectProperty&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/SymmetricObjectProperty&gt;
   &lt;AsymmetricObjectProperty&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/AsymmetricObjectProperty&gt;
   &lt;DisjointObjectProperties&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/DisjointObjectProperties&gt;
   &lt;ReflexiveObjectProperty&gt;
     &lt;ObjectProperty IRI="hasRelative"/&gt;
   &lt;/ReflexiveObjectProperty&gt;
   &lt;IrreflexiveObjectProperty&gt;
     &lt;ObjectProperty IRI="parentOf"/&gt;
   &lt;/IrreflexiveObjectProperty&gt;
   &lt;FunctionalObjectProperty&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/FunctionalObjectProperty&gt;
   &lt;InverseFunctionalObjectProperty&gt;
     &lt;ObjectProperty IRI="hasHusband"/&gt;
   &lt;/InverseFunctionalObjectProperty&gt;
   &lt;TransitiveObjectProperty&gt;
     &lt;ObjectProperty IRI="hasAncestor"/&gt;
   &lt;/TransitiveObjectProperty&gt;

   &lt;ObjectPropertyDomain&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;Class IRI="Man"/&gt;
   &lt;/ObjectPropertyDomain&gt;
   &lt;ObjectPropertyRange&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/ObjectPropertyRange&gt;

   &lt;InverseObjectProperties&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
   &lt;/InverseObjectProperties&gt;

   &lt;DisjointObjectProperties&gt;
     &lt;ObjectProperty IRI="hasSon"/&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
   &lt;/DisjointObjectProperties&gt;

   &lt;EquivalentObjectProperties&gt;
     &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;ObjectProperty abbreviatedIRI="otherOnt:child"/&gt;
   &lt;/EquivalentObjectProperties&gt;

   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;ObjectProperty IRI="hasSpouse"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectProperty IRI="hasFather"/&gt;
     &lt;ObjectProperty IRI="hasParent"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasGrandparent"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasFather"/&gt;
       &lt;ObjectProperty IRI="hasBrother"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/SubObjectPropertyOf&gt;
   &lt;SubObjectPropertyOf&gt;
     &lt;ObjectPropertyChain&gt;
       &lt;ObjectProperty IRI="hasFather"/&gt;
       &lt;ObjectProperty IRI="hasBrother"/&gt;
     &lt;/ObjectPropertyChain&gt;
     &lt;ObjectProperty IRI="hasUncle"/&gt;
   &lt;/SubObjectPropertyOf&gt;

   &lt;HasKey&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;DataProperty IRI="hasSSN"/&gt;
   &lt;/HasKey&gt;

   &lt;DataPropertyDomain&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/DataPropertyDomain&gt;
   &lt;DataPropertyRange&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;Datatype IRI="&amp;xsd;nonNegativeInteger"/&gt;
   &lt;/DataPropertyRange&gt;
   &lt;FunctionalDataProperty&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
   &lt;/FunctionalDataProperty&gt;
   &lt;EquivalentDataProperties&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;DataProperty abbreviatedIRI="otherOnt:age"/&gt;
   &lt;/EquivalentDataProperties&gt;

   &lt;SubClassOf&gt;
     &lt;Class IRI="Woman"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="Woman"/&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Grandfather"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Man"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Man"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;ObjectSomeValuesFrom&gt;
           &lt;ObjectInverseOf&gt;
             &lt;ObjectProperty IRI="hasParent"/&gt;
           &lt;/ObjectInverseOf&gt;
           &lt;Class abbreviatedIRI="owl:Thing"/&gt;
         &lt;/ObjectSomeValuesFrom&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;ObjectOneOf&gt;
         &lt;NamedIndividual IRI="Mary"/&gt;
         &lt;NamedIndividual IRI="Bill"/&gt;
         &lt;NamedIndividual IRI="Meg"/&gt;
       &lt;/ObjectOneOf&gt;
       &lt;Class IRI="Female"/&gt;
     &lt;/ObjectIntersectionOf&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Parent"/&gt;
       &lt;ObjectMaxCardinality cardinality="1"&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;/ObjectMaxCardinality&gt;
       &lt;ObjectAllValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="Female"/&gt;
       &lt;/ObjectAllValuesFrom&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Class IRI="Teenager"/&gt;
     &lt;DataSomeValuesFrom&gt;
       &lt;DataProperty IRI="hasAge"/&gt;
       &lt;DatatypeRestriction&gt;
         &lt;Datatype IRI="&amp;xsd;integer"/&gt;
         &lt;FacetRestriction facet="&amp;xsd;minExclusive"&gt;
           &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;12&lt;/Literal&gt;
         &lt;/FacetRestriction&gt;
         &lt;FacetRestriction facet="&amp;xsd;maxInclusive"&gt;
           &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;19&lt;/Literal&gt;
         &lt;/FacetRestriction&gt;
       &lt;/DatatypeRestriction&gt;
     &lt;/DataSomeValuesFrom&gt;
   &lt;/SubClassOf&gt;
   &lt;SubClassOf&gt;
     &lt;Annotation&gt;
       &lt;AnnotationProperty IRI="&amp;rdfs;comment"/&gt;
       &lt;Literal datatypeIRI="&amp;xsd;string"&gt;"States that every man is a person."&lt;/Literal&gt;
     &lt;/Annotation&gt;
     &lt;Class IRI="Man"/&gt;
     &lt;Class IRI="Person"/&gt;
   &lt;/SubClassOf&gt;

   &lt;EquivalentClasses&gt;
     &lt;Class IRI="HappyPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;ObjectAllValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="HappyPerson"/&gt;
       &lt;/ObjectAllValuesFrom&gt;
       &lt;ObjectSomeValuesFrom&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
         &lt;Class IRI="HappyPerson"/&gt;
       &lt;/ObjectSomeValuesFrom&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="JohnsChildren"/&gt;
     &lt;ObjectHasValue&gt;
       &lt;ObjectProperty IRI="hasParent"/&gt;
       &lt;NamedIndividual IRI="John"/&gt;
     &lt;/ObjectHasValue&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="NarcisticPerson"/&gt;
     &lt;ObjectHasSelf&gt;
       &lt;ObjectProperty IRI="loves"/&gt;
     &lt;/ObjectHasSelf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Orphan"/&gt;
     &lt;ObjectAllValuesFrom&gt;
       &lt;ObjectInverseOf&gt;
         &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;/ObjectInverseOf&gt;
       &lt;Class IRI="Dead"/&gt;
     &lt;/ObjectAllValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="MyBirthdayGuests"/&gt;
     &lt;ObjectOneOf&gt;
       &lt;NamedIndividual IRI="Bill"/&gt;
       &lt;NamedIndividual IRI="John"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
     &lt;/ObjectOneOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Adult"/&gt;
     &lt;Class abbreviatedIRI="otherOnt:Grownup"/&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Person"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectSomeValuesFrom&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Person"/&gt;
     &lt;/ObjectSomeValuesFrom&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Person"/&gt;
     &lt;Class IRI="Human"/&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="Parent"/&gt;
     &lt;ObjectUnionOf&gt;
       &lt;Class IRI="Mother"/&gt;
       &lt;Class IRI="Father"/&gt;
     &lt;/ObjectUnionOf&gt;
   &lt;/EquivalentClasses&gt;
   &lt;EquivalentClasses&gt;
     &lt;Class IRI="ChildlessPerson"/&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;Class IRI="Parent"/&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
   &lt;/EquivalentClasses&gt;

   &lt;DisjointClasses&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;Class IRI="Man"/&gt;
   &lt;/DisjointClasses&gt;
   &lt;DisjointClasses&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;Class IRI="Mother"/&gt;
     &lt;Class IRI="YoungChild"/&gt;
   &lt;/DisjointClasses&gt;

   &lt;DifferentIndividuals&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
   &lt;/DifferentIndividuals&gt;

   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="James"/&gt;
     &lt;NamedIndividual IRI="Jim"/&gt;
   &lt;/SameIndividual&gt;
   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual abbreviatedIRI="otherOnt:JohnBrown"/&gt;
   &lt;/SameIndividual&gt;
   &lt;SameIndividual&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
     &lt;NamedIndividual abbreviatedIRI="otherOnt:MaryBrown"/&gt;
   &lt;/SameIndividual&gt;

   &lt;ObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ObjectPropertyAssertion&gt;

   &lt;DataPropertyAssertion&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
     &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;51&lt;/Literal&gt;
   &lt;/DataPropertyAssertion&gt;

   &lt;ClassAssertion&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
       &lt;Class IRI="Woman"/&gt;
       &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectIntersectionOf&gt;
       &lt;Class IRI="Person"/&gt;
       &lt;ObjectComplementOf&gt;
         &lt;Class IRI="Parent"/&gt;
       &lt;/ObjectComplementOf&gt;
     &lt;/ObjectIntersectionOf&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;ClassAssertion&gt;
     &lt;ObjectMaxCardinality cardinality="4"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectMaxCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectMinCardinality cardinality="2"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectMinCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectExactCardinality cardinality="3"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
       &lt;Class IRI="Parent"/&gt;
     &lt;/ObjectExactCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;ObjectExactCardinality cardinality="5"&gt;
       &lt;ObjectProperty IRI="hasChild"/&gt;
     &lt;/ObjectExactCardinality&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;
   &lt;ClassAssertion&gt;
     &lt;Class IRI="Father"/&gt;
     &lt;NamedIndividual IRI="John"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;ClassAssertion&gt;
     &lt;Class IRI="SocialRole"/&gt;
     &lt;NamedIndividual IRI="Father"/&gt;
   &lt;/ClassAssertion&gt;

   &lt;NegativeObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasWife"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="Mary"/&gt;
   &lt;/NegativeObjectPropertyAssertion&gt;
   &lt;NegativeDataPropertyAssertion&gt;
     &lt;DataProperty IRI="hasAge"/&gt;
     &lt;NamedIndividual IRI="Jack"/&gt;
     &lt;Literal datatypeIRI="&amp;xsd;integer"&gt;53&lt;/Literal&gt;
   &lt;/NegativeDataPropertyAssertion&gt;
   &lt;NegativeObjectPropertyAssertion&gt;
     &lt;ObjectProperty IRI="hasDaughter"/&gt;
     &lt;NamedIndividual IRI="Bill"/&gt;
     &lt;NamedIndividual IRI="Susan"/&gt;
   &lt;/NegativeObjectPropertyAssertion&gt;
 
 &lt;/Ontology&gt;

</pre>
</div>
<div id="changelog">
<a id="Appendix:_Change_Log_.28Informative.29" name="Appendix:_Change_Log_.28Informative.29"></a><h2> <span class="mw-headline">14  Appendix: Change Log (Informative) </span></h2>
<a id="Changes_Since_Recommendation" name="Changes_Since_Recommendation"></a><h3> <span class="mw-headline">14.1  Changes Since Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/REC-owl2-primer-20091027/" rel="nofollow" title="http://www.w3.org/TR/2009/REC-owl2-primer-20091027/">Recommendation of 27 October, 2009</a>.
</p>
<ul><li> With the publication of the XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes <a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">Recommendation of 5 April 2012</a>,
 the elements of OWL 2 which are based on XSD 1.1 are now considered 
required, and the note detailing the optional dependency on the XSD 1.1 <a class="external text" href="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/" rel="nofollow" title="http://www.w3.org/TR/2009/CR-xmlschema11-2-20090430/">Candidate Recommendation of 30 April, 2009</a> has been removed from the "Status of this Document" section.
</li><li> Minor typographical errors were corrected as detailed on the <a class="external text" href="http://www.w3.org/2007/OWL/wiki/Errata" rel="nofollow" title="http://www.w3.org/2007/OWL/wiki/Errata">OWL 2 Errata</a> page.
</li></ul>
<a id="Changes_Since_Proposed_Recommendation" name="Changes_Since_Proposed_Recommendation"></a><h3> <span class="mw-headline">14.2  Changes Since Proposed Recommendation </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/PR-owl2-primer-20090922/" rel="nofollow" title="http://www.w3.org/TR/2009/PR-owl2-primer-20090922/">Proposed Recommendation of 22 September, 2009</a>.
</p>
<ul><li> Several editorial clarifications and improvements were made.
</li></ul>
<a id="Changes_Since_Last_Call" name="Changes_Since_Last_Call"></a><h3> <span class="mw-headline">14.3  Changes Since Last Call </span></h3>
<p>This section summarizes the changes to this document since the <a class="external text" href="http://www.w3.org/TR/2009/WD-owl2-primer-20090611/" rel="nofollow" title="http://www.w3.org/TR/2009/WD-owl2-primer-20090611/">Last Call Working Draft of 11 June, 2009</a>.
</p>
<ul><li> Errors in some of the examples were fixed.
</li><li> The example ontology was fixed so as to be consistent and syntactically correct.
</li><li> A section on OWL 2 tools was added.
</li><li> Various links to other OWL 2 documents were added.
</li><li> A note was added pointing out that a property being asymmetric
 is a much stronger notion than its being non-symmetric, and that being 
symmetric is a much stronger notion than being non-asymmetric.
</li><li> A note on the origin of the profile names was added, and it was pointed out that none of the profiles is a subset of another.
</li><li> Post Last Call changes to the OWL 2 syntax were incorporated.
</li><li> Several editorial clarifications and improvements, minor corrections and fixes, and cosmetic changes were made.
</li></ul>
</div>
<a id="Acknowledgments" name="Acknowledgments"></a><h2> <span class="mw-headline">15  Acknowledgments </span></h2>
<p>The starting point for the development of OWL 2 was the <a class="external text" href="http://www.w3.org/Submission/2006/10/" rel="nofollow" title="http://www.w3.org/Submission/2006/10/">OWL1.1 member submission</a>, itself a result of user and developer feedback, and in particular of information gathered during the <a class="external text" href="http://www.webont.org/owled/" rel="nofollow" title="http://www.webont.org/owled/">OWL Experiences and Directions (OWLED) Workshop series</a>. 
  The working group also considered <a class="external text" href="http://www.w3.org/2001/sw/WebOnt/webont-issues.html" rel="nofollow" title="http://www.w3.org/2001/sw/WebOnt/webont-issues.html">postponed issues</a> from the <a class="external text" href="http://www.w3.org/2004/OWL/" rel="nofollow" title="http://www.w3.org/2004/OWL/">WebOnt Working Group</a>.
</p><p>This document has been produced by the OWL Working Group (see 
below), and its contents reflect extensive discussions within the 
Working Group as a whole.
The editors extend special thanks to
Jie Bao (RPI),
Michel Dumontier (Carleton University),
Christine Goldbreich (Université de Versailles St-Quentin and LIRMM),
Henson Graves (Lockheed Martin),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Doug Lenat (Cycorp),
Deborah L. McGuinness (RPI),
Alan Rector (University of Manchester),
Alan Ruttenberg (Science Commons)
Uli Sattler (University of Manchester),
Michael Schneider (FZI), and
Mike Smith (Clark &amp; Parsia)
for their thorough reviews and helpful comments.
</p><p>The regular attendees at meetings of the OWL Working Group at the time of publication of this document were:
Jie Bao (RPI),
Diego Calvanese (Free University of Bozen-Bolzano),
Bernardo Cuenca Grau (Oxford University Computing Laboratory),
Martin Dzbor (Open University),
Achille Fokoue (IBM Corporation),
Christine Golbreich (Université de Versailles St-Quentin and LIRMM),
Sandro Hawke (W3C/MIT),
Ivan Herman (W3C/ERCIM),
Rinke Hoekstra (University of Amsterdam),
Ian Horrocks (Oxford University Computing Laboratory),
Elisa Kendall (Sandpiper Software),
Markus Krötzsch (FZI),
Carsten Lutz (Universität Bremen),
Deborah L. McGuinness (RPI),
Boris Motik (Oxford University Computing Laboratory),
Jeff Pan (University of Aberdeen),
Bijan Parsia (University of Manchester),
Peter F. Patel-Schneider (Bell Labs Research, Alcatel-Lucent),
Sebastian Rudolph (FZI),
Alan Ruttenberg (Science Commons),
Uli Sattler (University of Manchester),
Michael Schneider (FZI),
Mike Smith (Clark &amp; Parsia),
Evan Wallace (NIST),
Zhe Wu (Oracle Corporation), and
Antoine Zimmermann (DERI Galway).
We would also like to thank past members of the working group:
Jeremy Carroll,
Jim Hendler, and
Vipul Kashyap.
</p>
<a id="References" name="References"></a><h2> <span class="mw-headline">16  References </span></h2>
<dl><dt> <span id="ref-description-logics">[Description Logics]</span>
</dt><dd> <a class="external text" href="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254" rel="nofollow" title="http://www.cambridge.org/uk/catalogue/catalogue.asp?isbn=9780521876254"><cite>The Description Logic Handbook: Theory, Implementation, and Applications, second edition</cite></a>.
 Franz Baader, Diego Calvanese, Deborah L. McGuinness, Daniele Nardi, 
and Peter F. Patel-Schneider, eds. Cambridge University Press, 2007.  
Also see the <a class="external text" href="http://dl.kr.org/" rel="nofollow" title="http://dl.kr.org/"><cite>Description Logics Home Page</cite></a>.
</dd><dt> <span id="ref-dlp">[DLP]</span>
</dt><dd> <cite><a class="external text" href="http://www2003.org/cdrom/papers/refereed/p117/p117-grosof.html" rel="nofollow" title="http://www2003.org/cdrom/papers/refereed/p117/p117-grosof.html">Description Logic Programs: Combining Logic Programs with Description Logic</a></cite>.
 Benjamin N. Grosof, Ian Horrocks, Raphael Volz, and Stefan Decker. in 
Proc. of the 12th Int. World Wide Web Conference (WWW 2003), Budapest, 
Hungary, 2003. pp.: 48–57
</dd><dt> <span id="ref-DL-Lite">[DL-Lite]</span>
</dt><dd> <cite><a class="external text" href="http://www.springerlink.com/content/n17338715966v81h/" rel="nofollow" title="http://www.springerlink.com/content/n17338715966v81h/">Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family</a></cite>.
 Diego Calvanese, Giuseppe de Giacomo, Domenico Lembo, Maurizio 
Lenzerini, Riccardo Rosati. J. of Automated Reasoning 39(3):385–429, 
2007
</dd><dt> <span id="ref-ELpp">[EL++]</span>
</dt><dd> <cite><a class="external text" href="http://www.informatik.uni-bremen.de/~clu/papers/archive/ijcai05.pdf" rel="nofollow" title="http://www.informatik.uni-bremen.de/~clu/papers/archive/ijcai05.pdf">Pushing the EL Envelope</a></cite>.
 Franz Baader, Sebastian Brandt, and Carsten Lutz. In Proc. of the 19th 
Joint Int. Conf. on Artificial Intelligence (IJCAI 2005), 2005
</dd><dt> <span id="ref-FOST">[FOST]</span>
</dt><dd> <cite><a class="external text" href="http://www.semantic-web-book.org/" rel="nofollow" title="http://www.semantic-web-book.org">Foundations of Semantic Web Technologies</a></cite>. Pascal Hitzler, Markus Krötzsch, and Sebastian Rudolph. Chapman &amp; Hall/CRC, 2009, ISBN: 9781420090505.
</dd><dt> <span id="ref-owl-2-conformance">[OWL 2 Conformance]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">OWL 2 Web Ontology Language: <span>Conformance (Second Edition)</span></a></cite> Michael Smith, Ian Horrocks, Markus Krötzsch, Birte Glimm, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/">http://www.w3.org/TR/2012/REC-owl2-conformance-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-conformance/">http://www.w3.org/TR/owl2-conformance/</a>.</span></dd><dt> <span id="ref-owl-2-manchester-syntax">[OWL 2 曼彻斯特语法]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/">OWL 2 Web Ontology Language: <span>曼彻斯特语法 (Second Edition)</span></a></cite> Matthew Horridge, Peter F. Patel-Schneider. W3C Working Group Note, 11 December 2012, <a href="http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/">http://www.w3.org/TR/2012/NOTE-owl2-manchester-syntax-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-manchester-syntax/">http://www.w3.org/TR/owl2-manchester-syntax/</a>.</span></dd><dt> <span id="ref-owl-2-new-features">[OWL 2 New Features and Rationale]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/">OWL 2 Web Ontology Language: <span>New Features and Rationale (Second Edition)</span></a></cite> Christine Golbreich, Evan K. Wallace, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/">http://www.w3.org/TR/2012/REC-owl2-new-features-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-new-features/">http://www.w3.org/TR/owl2-new-features/</a>.</span></dd><dt> <span id="ref-owl-2-profiles">[OWL 2 Profiles]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/">OWL 2 Web Ontology Language: <span>Profiles (Second Edition)</span></a></cite>
 Boris Motik, Bernardo Cuenca Grau, Ian Horrocks, Zhe Wu, Achille 
Fokoue, Carsten Lutz, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/">http://www.w3.org/TR/2012/REC-owl2-profiles-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-profiles/">http://www.w3.org/TR/owl2-profiles/</a>.</span></dd><dt> <span id="ref-owlprofilesintro">[OWL 2 Profiles Introduction]</span>
</dt><dd> <cite>OWL 2 Profiles: An Introduction to Lightweight Ontology Languages</cite>.
 Markus Krötzsch. Reasoning Web 2012. Lecture Notes in Computer Science,
 vol. 7487, pp. 112–183, Springer 2012. To appear. Preprint available at
 <a class="external free" href="http://korrekt.org/page/OWL_2_Profiles" rel="nofollow" title="http://korrekt.org/page/OWL_2_Profiles">http://korrekt.org/page/OWL_2_Profiles</a>
</dd><dt> <span id="ref-owl-2-quick-reference">[OWL 2 Quick Reference Guide]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">OWL 2 Web Ontology Language: <span>Quick Reference Guide (Second Edition)</span></a></cite> Jie Bao, Elisa F. Kendall, Deborah L. McGuinness, Peter F. Patel-Schneider, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/">http://www.w3.org/TR/2012/REC-owl2-quick-reference-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-quick-reference/">http://www.w3.org/TR/owl2-quick-reference/</a>.</span></dd><dt> <span id="ref-owl-2-rdf-semantics">[OWL 2 RDF-Based Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">OWL 2 Web Ontology Language: <span>RDF-Based Semantics (Second Edition)</span></a></cite> Michael Schneider, editor. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-rdf-based-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-rdf-based-semantics/">http://www.w3.org/TR/owl2-rdf-based-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-rdf-mapping">[OWL 2 RDF Mapping]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">OWL 2 Web Ontology Language: <span>Mapping to RDF Graphs (Second Edition)</span></a></cite> Peter F. Patel-Schneider, Boris Motik, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">http://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-mapping-to-rdf/">http://www.w3.org/TR/owl2-mapping-to-rdf/</a>.</span></dd><dt> <span id="ref-owl-2-direct-semantics">[OWL 2 Direct Semantics]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">OWL 2 Web Ontology Language: <span>Direct Semantics (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bernardo Cuenca Grau, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/">http://www.w3.org/TR/2012/REC-owl2-direct-semantics-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-direct-semantics/">http://www.w3.org/TR/owl2-direct-semantics/</a>.</span></dd><dt> <span id="ref-owl-2-specification">[OWL 2 Specification]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">OWL 2 Web Ontology Language: <span>Structural Specification and 函数式语法 (Second Edition)</span></a></cite> Boris Motik, Peter F. Patel-Schneider, Bijan Parsia, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/">http://www.w3.org/TR/2012/REC-owl2-syntax-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-syntax/">http://www.w3.org/TR/owl2-syntax/</a>.</span></dd><dt> <span id="ref-owl-2-xml-serialization">[OWL 2 XML Serialization]</span>
</dt><dd><span><cite><a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">OWL 2 Web Ontology Language: <span>XML Serialization (Second Edition)</span></a></cite> Boris Motik, Bijan Parsia, Peter F. Patel-Schneider, eds. W3C Recommendation, 11 December 2012, <a href="http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/">http://www.w3.org/TR/2012/REC-owl2-xml-serialization-20121211/</a>.  Latest version available at <a href="http://www.w3.org/TR/owl2-xml-serialization/">http://www.w3.org/TR/owl2-xml-serialization/</a>.</span></dd><dt> <span id="ref-pdstar">[pD*]</span>
</dt><dd> <cite><a class="external text" href="http://linkinghub.elsevier.com/retrieve/pii/S1570826805000144" rel="nofollow" title="http://linkinghub.elsevier.com/retrieve/pii/S1570826805000144">Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary</a></cite>. Herman J. ter Horst. J. of Web Semantics 3(2–3):79–115, 2005
</dd><dt> <span id="ref-rdf-concepts">[RDF Concepts]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a></cite>.
 Graham Klyne and Jeremy J. Carroll, eds. W3C Recommendation, 10 
February 2004, http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/.  
Latest version available as http://www.w3.org/TR/rdf-concepts/.
</dd><dt> <span id="ref-rdf-semantics">[RDF Semantics]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF Semantics</a></cite>.
 Patrick Hayes, ed., W3C Recommendation, 10 February 2004, 
http://www.w3.org/TR/2004/REC-rdf-mt-20040210/.  Latest version 
available as http://www.w3.org/TR/rdf-mt/.
</dd><dt> <span id="ref-rdf-syntax">[RDF Syntax]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/" rel="nofollow" title="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">RDF/XML 语法 Specification (Revised)</a></cite>.
 Dave Beckett, ed. W3C Recommendation, 10 February 2004, 
http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/.  Latest 
version available as http://www.w3.org/TR/rdf-syntax-grammar/.
</dd><dt> <span id="ref-rfc-3987">[RFC 3987]</span>
</dt><dd> <cite><a class="external text" href="http://www.ietf.org/rfc/rfc3987.txt" rel="nofollow" title="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987: Internationalized Resource Identifiers (IRIs)</a></cite>. M. Duerst and M. Suignard. IETF, January 2005, http://www.ietf.org/rfc/rfc3987.txt
</dd><dt> <span id="ref-sparql">[SPARQL]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/" rel="nofollow" title="http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for RDF</a></cite>.
 Eric Prud'hommeaux and Andy Seaborne, eds. W3C Recommendation, 15 
January 2008, http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/. 
 Latest version available as http://www.w3.org/TR/rdf-sparql-query/.
</dd><dt> <span id="ref-turtle">[Turtle]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/turtle/" rel="nofollow" title="http://www.w3.org/TR/turtle/">Turtle: Terse RDF Triple Language</a></cite>.
 Eric Prud'hommeaux and Gavin Carothers.  W3C Last Call Working Draft, 
10 July 2012, http://www.w3.org/TR/2012/WD-turtle-20120710/.  Latest 
version available at http://www.w3.org/TR/turtle/.
</dd><dt> <span id="ref-xml-schema-datatypes">[XML Schema Datatypes]</span>
</dt><dd> <cite><a class="external text" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a></cite>.
 David Peterson, Shudi (Sandy) Gao, Ashok Malhotra, C. M. 
Sperberg-McQueen, and Henry S. Thompson, eds. (Version 1.1) and Paul V. 
Biron, and Ashok Malhotra, eds. (Version 1.0). W3C Recommendation, 5 
April 2012, <a class="external free" href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/" rel="nofollow" title="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/</a>. Latest version available as <a class="external free" href="http://www.w3.org/TR/xmlschema11-2/" rel="nofollow" title="http://www.w3.org/TR/xmlschema11-2/">http://www.w3.org/TR/xmlschema11-2/</a>.
</dd></dl>
<p><br>
<script type="text/javascript">primerOnLoad();</script>
</p>


<script src="OWL%202%20Web%20Ontology%20Language%20Primer%20(Second%20Edition)_files/fixup.js"></script>
</body></html>